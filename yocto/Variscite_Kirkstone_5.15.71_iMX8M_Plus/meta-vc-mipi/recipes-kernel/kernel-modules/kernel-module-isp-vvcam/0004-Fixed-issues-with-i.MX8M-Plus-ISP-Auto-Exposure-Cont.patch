From db0e83565f9d624942590a9393de44ccdef33210 Mon Sep 17 00:00:00 2001
From: Peter Martienssen <peter.martienssen@liquify-consulting.de>
Date: Wed, 6 Nov 2024 10:25:03 +0100
Subject: [PATCH 4/4] Fixed issues with i.MX8M Plus ISP Auto Exposure Control

---
 .../sensor/vc-mipi-vvcam/vc_mipi_camera.c     |  64 ++++---
 .../v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c  | 173 +++++++++++-------
 .../v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h  |  26 +--
 .../sensor/vc-mipi-vvcam/vc_mipi_modules.c    |  64 ++++---
 4 files changed, 200 insertions(+), 127 deletions(-)

diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
index 2d6a09d..c8b5472 100644
--- a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
@@ -13,7 +13,7 @@
 #include "vvsensor.h"
 #endif
 
-#define VERSION "0.3.0"
+#define VERSION "0.3.0.pre2"
 
 #define V4L2_CID_CSI_LANES      (V4L2_CID_LASTP1 + 0)
 #define V4L2_CID_TRIGGER_MODE   (V4L2_CID_LASTP1 + 1)
@@ -138,7 +138,7 @@ static int vc_sd_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)
                 return vc_sen_set_exposure(cam, control->value);
 
         case V4L2_CID_GAIN:
-                return vc_sen_set_gain(cam, control->value);
+                return vc_sen_set_gain(cam, control->value, true);
         
         case V4L2_CID_CSI_LANES:
                 return vc_core_set_num_lanes(cam, ctrl_csi_lanes_menu[control->value]);
@@ -211,7 +211,7 @@ static int vc_sd_s_stream(struct v4l2_subdev *sd, int enable)
                 ret |= vc_sen_set_roi(cam);
                 if (!ret && reset) {
                         ret |= vc_sen_set_exposure(cam, cam->state.exposure);
-                        ret |= vc_sen_set_gain(cam, cam->state.gain);
+                        ret |= vc_sen_set_gain(cam, cam->state.gain, true);
                         ret |= vc_sen_set_blacklevel(cam, cam->state.blacklevel);
                 }
 
@@ -388,7 +388,7 @@ static int vc_vidioc_querycap(struct vc_device *device, void *arg)
         return 0;
 }
 
-// #define DEBUG_MODE_INFO
+#define DEBUG_MODE_INFO
 static void vc_get_mode_info(struct vc_device *device, struct vvcam_mode_info_s *info)
 {
         struct vc_cam *cam = &device->cam;
@@ -401,6 +401,16 @@ static void vc_get_mode_info(struct vc_device *device, struct vvcam_mode_info_s
         __u32 code = vc_core_get_format(cam);
         __u32 time_per_line_ns = vc_core_get_time_per_line_ns(cam);
         __u32 framerate = vc_core_get_framerate(cam);
+        __u32 max_integration_line = (((__u64)10000000000000 / framerate / time_per_line_ns)+5)/10;
+        __u64 max_again = (vc_core_mdB_to_times(cam->ctrl.again.max_mdB) * 1024 ) / 1000;
+        __u64 max_dgain = (vc_core_mdB_to_times(cam->ctrl.dgain.max_mdB) * 1024 ) / 1000;
+        #define MAX_GAIN 0xffffffff
+        if (max_again > MAX_GAIN) {
+                max_again = MAX_GAIN;
+        }
+        if (max_dgain > MAX_GAIN) {
+                max_dgain = MAX_GAIN;
+        }
 
         // Required infos for streaming
         info->index = 0;
@@ -453,24 +463,24 @@ static void vc_get_mode_info(struct vc_device *device, struct vvcam_mode_info_s
                 info->bayer_pattern = BAYER_GBRG;
                 break;
         }
-        
+
         // Required infos for auto exposure control
-        info->ae_info.one_line_exp_time_ns  = time_per_line_ns;
-        info->ae_info.max_integration_line  = (__u64)1000000000000 / framerate / time_per_line_ns;
-        info->ae_info.min_integration_line  = mode.vmax.min;
-        info->ae_info.def_frm_len_lines     = 0;
-        info->ae_info.curr_frm_len_lines    = 0;
-        info->ae_info.start_exposure        = 0;
-
-        info->ae_info.max_again             = cam->ctrl.gain.max_mdB;           // mdB
-        info->ae_info.min_again             = 1;                                // mdB
-        info->ae_info.max_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mdB 
-        info->ae_info.min_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mdB
+        info->ae_info.one_line_exp_time_ns  = time_per_line_ns;                         // ns 
+        info->ae_info.max_integration_line  = max_integration_line;                     // lines
+        info->ae_info.min_integration_line  = mode.vmax.min;                            // lines
+        info->ae_info.def_frm_len_lines     = cam->ctrl.frame.height;                   // lines
+        info->ae_info.curr_frm_len_lines    = cam->ctrl.frame.height;                   // lines
+        info->ae_info.start_exposure        = max_integration_line;                     // lines
+
+        info->ae_info.max_again             = max_again;                                // times
+        info->ae_info.min_again             = 1 * (1 << SENSOR_FIX_FRACBITS);           // times
+        info->ae_info.max_dgain             = max_dgain;                                // times
+        info->ae_info.min_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS);           // times
         
-        info->ae_info.cur_fps               = framerate;                        // mHz
-        info->ae_info.max_fps               = cam->ctrl.framerate.max;          // mHz
-        info->ae_info.min_fps               = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mHz
-        info->ae_info.min_afps              = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mHz
+        info->ae_info.cur_fps               = framerate;                                // mHz
+        info->ae_info.max_fps               = cam->ctrl.framerate.max;                  // mHz
+        info->ae_info.min_fps               = 1 * (1 << SENSOR_FIX_FRACBITS);           // 1024 mHz
+        info->ae_info.min_afps              = 1 * (1 << SENSOR_FIX_FRACBITS);           // 1024 mHz
 
         info->ae_info.int_update_delay_frm  = 1;
         info->ae_info.gain_update_delay_frm = 1;
@@ -489,7 +499,10 @@ static void vc_get_mode_info(struct vc_device *device, struct vvcam_mode_info_s
         vc_info(dev, "%s(): curr_frm_len_lines:   %5u lines\n", __func__, info->ae_info.curr_frm_len_lines);
         vc_info(dev, "%s(): start_exposure:       %5u lines\n", __func__, info->ae_info.start_exposure);
         vc_info(dev, "%s(): ------------------------------------------\n", __func__);
-        vc_info(dev, "%s(): max_again:            %5u mdB\n", __func__, info->ae_info.max_again);
+        vc_info(dev, "%s(): max_again:       %10u times\n", __func__, info->ae_info.max_again);
+        vc_info(dev, "%s(): min_again:       %10u times\n", __func__, info->ae_info.min_again);
+        vc_info(dev, "%s(): max_dgain:       %10u times\n", __func__, info->ae_info.max_dgain);
+        vc_info(dev, "%s(): min_dgain:       %10u times\n", __func__, info->ae_info.min_dgain);
         vc_info(dev, "%s(): ------------------------------------------\n", __func__);
         vc_info(dev, "%s(): cur_fps:              %5u mHz\n", __func__, info->ae_info.cur_fps);
         vc_info(dev, "%s(): max_fps:              %5u mHz\n", __func__, info->ae_info.max_fps);
@@ -544,8 +557,11 @@ static long vc_sd_vvsensorioc(struct v4l2_subdev *sd, unsigned int cmd, void *ar
                 ret = vc_sen_set_exposure(&device->cam, ((*(u32 *)arg) * vc_core_get_time_per_line_ns(cam)) / 1000);
                 break;
         case VVSENSORIOC_S_GAIN:
-                vc_info(sd->dev, "%s(): VVSENSORIOC_S_GAIN [%u]\n", __func__, *(u32 *)arg);
-                ret = vc_sen_set_gain(&device->cam, *(u32 *)arg);
+                {
+                __u64 gain = *(u32 *)arg;
+                vc_info(sd->dev, "%s(): VVSENSORIOC_S_GAIN [%llu]\n", __func__, gain);
+                ret = vc_sen_set_gain(&device->cam, (gain * 1000) / 1024, false);
+                }
                 break;
         case VVSENSORIOC_S_FPS:
                 vc_info(sd->dev, "%s(): VVSENSORIOC_S_FPS [%u]\n", __func__, *(u32 *)arg);
@@ -851,7 +867,7 @@ static int vc_sd_init(struct vc_device *device)
                 device->cam.ctrl.exposure.min, device->cam.ctrl.exposure.max,
                 device->cam.ctrl.exposure.def);
         ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_GAIN, 
-                0, device->cam.ctrl.gain.max_mdB, 0);
+                0, device->cam.ctrl.again.max_mdB + device->cam.ctrl.dgain.max_mdB, 0);
         ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_csi_lanes);
         ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_black_level);
         ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_trigger_mode);
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
index 7e486bd..3036121 100755
--- a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
@@ -67,7 +67,7 @@ int debug = 3;
 struct device *vc_core_get_mod_device(struct vc_cam *cam);
 int vc_core_try_format(struct vc_cam *cam, __u32 code);
 __u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
-__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning, __u32 height);
 static __u32 vc_core_calculate_period_1H(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
 void vc_core_calculate_roi(struct vc_cam *cam, __u32 *w_left, __u32 *w_right, __u32 *w_width,
         __u32 *w_top, __u32 *w_bottom, __u32 *w_height, __u32 *o_width, __u32 *o_height);
@@ -307,23 +307,24 @@ static void vc_core_print_mode(struct vc_cam *cam)
         int index = 0;
 
         if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
-                vc_notice(dev, "+-------+--------+------------+-----------+\n");
-                vc_notice(dev, "| lanes | format | exposure   | framerate |\n");
-                vc_notice(dev, "|       |        | max [us]   | max [mHz] |\n");
-                vc_notice(dev, "+-------+--------+------------+-----------+\n");
+                vc_notice(dev, "+-------+--------+---------+------------+-----------+\n");
+                vc_notice(dev, "| lanes | format | binning | exposure   | framerate |\n");
+                vc_notice(dev, "|       |        | mode    | max [us]   | max [mHz] |\n");
+                vc_notice(dev, "+-------+--------+---------+------------+-----------+\n");
                 while (index < MAX_VC_MODES && ctrl->mode[index].num_lanes != 0) {
                         __u8 num_lanes = ctrl->mode[index].num_lanes;
                         __u8 format = ctrl->mode[index].format;
                         __u8 binning = ctrl->mode[index].binning;
+                        __u32 height = ctrl->frame.height;
                         __u32 max_exposure = vc_core_calculate_max_exposure(cam, num_lanes, format, binning);
-                        __u32 max_frame_rate = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning);
+                        __u32 max_frame_rate = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning, height);
 
                         vc_core_print_format(format, sformat);
-                        vc_notice(dev, "|     %1d | %s  | %10d | %9d |\n",
-                                num_lanes, sformat, max_exposure, max_frame_rate);
+                        vc_notice(dev, "|     %1d | %s  |       %1d | %10d | %9d |\n",
+                                num_lanes, sformat, binning, max_exposure, max_frame_rate);
                         index++;
                 }
-                vc_notice(dev, "+-------+--------+------------+-----------+\n");
+                vc_notice(dev, "+-------+--------+---------+------------+-----------+\n");
         }
 }
 
@@ -769,32 +770,30 @@ __u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 fo
         }
 }
 
-__u32 vc_core_get_optimized_vmax(struct vc_cam *cam)
+__u32 vc_core_get_optimized_vmax(struct vc_cam *cam, __u8 num_lanes,  __u8 format, __u8 binning_mode, __u32 height)
 {
         struct vc_ctrl *ctrl = &cam->ctrl;
-        struct vc_state *state = &cam->state;
         struct device *dev = &ctrl->client_sen->dev;
-        __u8 num_lanes = state->num_lanes;
-        __u8 format = vc_core_mbus_code_to_format(state->format_code);
-        __u8 binning_mode = state->binning_mode;
         __u32 vmax_def = vc_core_get_vmax(cam, num_lanes, format, binning_mode).def;
         struct vc_binning *binning = vc_core_get_binning(cam);
-        __u32 height = state->frame.height;
         __u32 vmax_res = vmax_def;
 
-        if ( 0 == vmax_def) {
-                return vmax_def;
+        if (0 == vmax_def) {
+                return 0;
         }
 
         if (binning->v_factor > 0) {
-                height = state->frame.height * binning->v_factor;
+                height *= binning->v_factor;
         }
 
+        vc_dbg(dev, "%s(): vmax_def: %u, v_factor: %u, height: %u/%u\n", __FUNCTION__,
+                vmax_def, binning->v_factor, height, ctrl->frame.height);
+
         // Increase the frame rate when image height is reduced.
         if (ctrl->flags & FLAG_INCREASE_FRAME_RATE && height < ctrl->frame.height) {
                 vmax_res = vmax_def - (ctrl->frame.height - height);
-                vc_dbg(dev, "%s(): Increased frame rate: vmax %u/%u, height: %u/%u, vmax result: %u \n", __FUNCTION__,
-                        state->vmax, vmax_def, state->frame.height, ctrl->frame.height, vmax_res);
+                vc_dbg(dev, "%s(): Increased frame rate: vmax: %u \n", __FUNCTION__,
+                        vmax_res);
 
                 return vmax_res;
         }
@@ -802,17 +801,18 @@ __u32 vc_core_get_optimized_vmax(struct vc_cam *cam)
         return vmax_def;
 }
 
-__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning, __u32 height)
 {
         struct device *dev = vc_core_get_sen_device(cam);
         __u32 period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format, binning);
-        __u32 vmax = vc_core_get_optimized_vmax(cam);
+        __u32 vmax = vc_core_get_optimized_vmax(cam, num_lanes, format, binning, height);
         __u32 vmax_def = vc_core_get_vmax(cam, num_lanes, format, binning).def;
+        __u32 frame_rate = 1000000000 / (((__u64)period_1H_ns * vmax) / 1000);
 
-        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax: %u/%u\n",
-                __FUNCTION__, period_1H_ns, vmax, vmax_def);
+        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax: %u/%u, max_frame_rate: %u\n",
+                __FUNCTION__, period_1H_ns, vmax, vmax_def, frame_rate);
 
-        return 1000000000 / (((__u64)period_1H_ns * vmax) / 1000);
+        return frame_rate;
 }
 
 
@@ -1006,9 +1006,10 @@ int vc_core_update_controls(struct vc_cam *cam)
         __u8 num_lanes = state->num_lanes;
         __u8 format = vc_core_mbus_code_to_format(state->format_code);
         __u8 binning = state->binning_mode;
+        __u32 height = state->frame.height;
         if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
                 ctrl->exposure.max = vc_core_calculate_max_exposure(cam, num_lanes, format, binning);
-                ctrl->framerate.max = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning);
+                ctrl->framerate.max = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning, height);
 
                 vc_dbg(dev, "%s(): num_lanes: %u, format %u, exposure.max: %u us, framerate.max: %u mHz\n",
                         __FUNCTION__, num_lanes, format, ctrl->exposure.max, ctrl->framerate.max);
@@ -1079,7 +1080,7 @@ int vc_core_init(struct vc_cam *cam, struct i2c_client *client)
         vc_core_update_controls(cam);
         vc_core_print_mode(cam);
 
-        vc_notice(&ctrl->client_mod->dev, "VC MIPI Core successfully initialized");
+        vc_notice(&ctrl->client_mod->dev, "VC MIPI Core successfully initialized\n");
         return 0;
 }
 EXPORT_SYMBOL(vc_core_init);
@@ -1497,7 +1498,11 @@ void vc_core_calculate_roi(struct vc_cam *cam, __u32 *left, __u32 *right, __u32
         struct i2c_client *client = ctrl->client_sen;
         struct device *dev = &client->dev;
         struct vc_binning *binning = vc_core_get_binning(cam);
+#ifdef ENABLE_ADVANCED_CONTROL
         __u32 frame_height = state->frame.height + state->height_offset;
+#else
+        __u32 frame_height = state->frame.height;
+#endif
 
         if (NULL == binning) {
                 vc_err(dev, "%s() Could not get binning struct!\n", __FUNCTION__);
@@ -1681,70 +1686,109 @@ static int vc_sen_write_flash_offset(struct vc_ctrl *ctrl, __u32 offset)
         return i2c_write_reg4(dev, client, &ctrl->csr.sen.flash_offset, offset, __FUNCTION__);
 }
 
-static int vc_core_mdB_to_times(int mdB)
+// times = 10^(mdB/10000) = 1.000230285^mdB
+#define FACTOR 100023
+#define BASE   100000
+
+__u64 vc_core_mdB_to_times(int mdB)
 {
-        // times = 10^(mdB/10000) = 1.000230285^mdB
-        __u64 base = 100023028; 
-        __u64 times = base;
+        __u64 times = FACTOR;
         int index = 0;
         for (index = 1; index <= mdB; index++) {
-                times = (times * base) / 100000000;
+                times = (times * FACTOR) / BASE;
         }
-        return times / 100000;
+        return (times * 1000) / BASE;
 }
+EXPORT_SYMBOL(vc_core_mdB_to_times);
 
-int vc_sen_set_gain(struct vc_cam *cam, int gain_mdB)
+int vc_core_times_to_mdB(__u64 times)
+{
+        int mdB = 0;
+        __u64 res = ((__u64)times * BASE) / 1000;
+        while (res > BASE) {
+                res = (res * BASE) / FACTOR;
+                mdB++;
+        }
+        return mdB;
+}
+EXPORT_SYMBOL(vc_core_times_to_mdB);
+
+int vc_sen_set_gain(struct vc_cam *cam, __u64 gain, bool unit_is_mdB)
 {
         struct vc_ctrl *ctrl = &cam->ctrl;
         struct i2c_client *client = ctrl->client_sen;
         struct device *dev = &client->dev;
-        int gain_times = 0;
-        int gain_fraction = 0;
-        int gain = 0;
+        int gain_mdB = 0;
+        int again_mdB = 0, again_times = 0, again_fraction = 0, again = 0;
+        int dgain_mdB = 0, dgain_times = 0, dgain = 0;
         int ret = 0;
 
-        if (gain_mdB < 0) {
-                gain_mdB = 0;
+        if (unit_is_mdB) {
+                gain_mdB = gain;
+        } else {
+                gain_mdB = vc_core_times_to_mdB(gain);
         }
-        if (gain_mdB > ctrl->gain.max_mdB) {
-                gain_mdB = ctrl->gain.max_mdB;
+
+        if (gain_mdB > ctrl->again.max_mdB) {
+                again_mdB = ctrl->again.max_mdB;
+                dgain_mdB = gain_mdB - ctrl->again.max_mdB;
+                if (dgain_mdB > ctrl->dgain.max_mdB) {
+                        dgain_mdB = ctrl->dgain.max_mdB;
+                }
+        } else {
+                again_mdB = gain_mdB;
+                dgain_mdB = 0;
         }
 
-        switch (ctrl->gain.type) {
+        switch (ctrl->again.type) {
         case GAIN_LINEAR:
-                gain = ((1000000 * (__u64)ctrl->gain.max) / ctrl->gain.max_mdB) 
-                        * gain_mdB / 1000000;
+                again_times = vc_core_mdB_to_times(again_mdB);
+                again = ((1000000 * (__u64)ctrl->again.max) / ctrl->again.max_mdB) 
+                        * again_mdB / 1000000;
+                vc_dbg(dev, "%s(): GAIN_LIN %u mdB -> %u\n", __FUNCTION__, again_mdB, again);
                 break;
 
         case GAIN_LOGARITHMIC:
-                gain_times = 1000000/vc_core_mdB_to_times(gain_mdB/2);
-                vc_dbg (dev, "%s(): GAIN_LOG %u mdB -> %u times\n", __FUNCTION__, gain_mdB, gain_times);
-                gain = (1000 * ctrl->gain.c1 - gain_times * ctrl->gain.c0) / 1000;
+                again_times = 1000000/vc_core_mdB_to_times(again_mdB/2);
+                again = (1000 * ctrl->again.c1 - again_times * ctrl->again.c0) / 1000;
+                vc_dbg(dev, "%s(): GAIN_LOG %u mdB -> %u times\n", __FUNCTION__, again_mdB, again_times);
                 break;
 
         case GAIN_RECIPROCAL:
-                gain_times = vc_core_mdB_to_times(gain_mdB);
-                vc_dbg(dev, "%s(): GAIN_REC %u mdB -> %u times\n", __FUNCTION__, gain_mdB, gain_times);
-                gain = ctrl->gain.c1 - 1000 * (__u64)ctrl->gain.c0 / gain_times;
+                again_times = vc_core_mdB_to_times(again_mdB);
+                again = ctrl->again.c1 - 1000 * (__u64)ctrl->again.c0 / again_times;
+                vc_dbg(dev, "%s(): GAIN_REC %u mdB -> %u times\n", __FUNCTION__, again_mdB, again_times);
                 break;
 
         case GAIN_FRACTIONAL:
-                gain_times = vc_core_mdB_to_times(gain_mdB);
-                gain_fraction = (( gain_times - (gain_times / 1000) * 1000) * 16 ) / 1000;
-                gain = (gain_times / 1000 << 4) + gain_fraction;
-                vc_dbg(dev, "%s(): GAIN_FRA %u mdB -> %u times (%u.%u) => 0x%02x\n", __FUNCTION__, gain_mdB, gain_times,
-                        gain_times / 1000, gain_fraction, gain );
+                again_times = vc_core_mdB_to_times(again_mdB);
+                again_fraction = (( again_times - (again_times / 1000) * 1000) * 16 ) / 1000;
+                again = (again_times / 1000 << 4) + again_fraction;
+                vc_dbg(dev, "%s(): GAIN_FRA %u mdB -> %u times (%u.%u) => 0x%02x\n", __FUNCTION__, again_mdB, again_times,
+                        again_times / 1000, again_fraction, again );
                 break;
         }
+        if (again > ctrl->again.max) {
+                again = ctrl->again.max;
+        }
 
-        if (gain > ctrl->gain.max) {
-                gain = ctrl->gain.max;
+        switch (ctrl->dgain.type) {
+        default:
+                dgain_times = vc_core_mdB_to_times(dgain_mdB);
+                dgain = (dgain_times / 1000 << 8) + ((dgain_times - (dgain_times / 1000) * 1000) * 256 ) / 1000;
+                break;
+        }
+        if (dgain > ctrl->dgain.max) {
+                dgain = ctrl->dgain.max;
         }
 
-        vc_notice(dev, "%s(): Set sensor gain: %u mdB (%u/%u) (exposure: %u us)\n", __FUNCTION__, 
-                gain_mdB, gain, ctrl->gain.max, cam->state.exposure);
+        vc_dbg(dev, "%s(): gain:%llu %s, again:%ux/%u/%u, dgain:%ux/%u/%u\n", __FUNCTION__, 
+                gain, unit_is_mdB?"mdB":"times", again_times, again, ctrl->again.max, dgain_times, dgain, ctrl->dgain.max);
+        vc_notice(dev, "%s(): Set sensor gain: %u mdB (exposure: %u us)\n", __FUNCTION__, 
+                gain_mdB, cam->state.exposure);
 
-        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.gain, gain, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.again, again, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.dgain, dgain, __FUNCTION__);
         if (ret) {
                 vc_err(dev, "%s(): Couldn't set gain (error: %d)\n", __FUNCTION__, ret);
                 return ret;
@@ -1900,10 +1944,14 @@ static void vc_core_calculate_vmax(struct vc_cam *cam, __u32 period_1H_ns)
         struct vc_ctrl *ctrl = &cam->ctrl;
         struct vc_state *state = &cam->state;
         struct device *dev = &ctrl->client_sen->dev;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 height = state->frame.height;
         __u64 frametime_ns;
         __u64 frametime_1H;
 
-        state->vmax = vc_core_get_optimized_vmax(cam);
+        state->vmax = vc_core_get_optimized_vmax(cam, num_lanes, format, binning, height);
         // Lower the frame rate if the frame rate setting requires it.
         if (state->framerate > 0) {
                 frametime_ns = 1000000000000 / state->framerate;
@@ -2076,7 +2124,8 @@ int vc_sen_set_exposure(struct vc_cam *cam, int exposure_us)
         struct i2c_client *client_mod = ctrl->client_mod;
         int ret = 0;
 
-        vc_notice(dev, "%s(): Set sensor exposure: %u us\n", __FUNCTION__, exposure_us);
+        vc_notice(dev, "%s(): Set sensor exposure: %u us (gain: %u mdB)\n", __FUNCTION__, 
+                exposure_us, cam->state.gain);
 
         if (exposure_us < ctrl->exposure.min)
                 exposure_us = ctrl->exposure.min;
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
index f7cf1ad..2e83384 100755
--- a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
@@ -2,7 +2,7 @@
 #define _VC_MIPI_CORE_H
 
 // #define DEBUG
-#define ENABLE_ADVANCED_CONTROL
+// #define ENABLE_ADVANCED_CONTROL
 
 #include <linux/types.h>
 #include <linux/i2c.h>
@@ -149,7 +149,8 @@ struct vc_sen_csr {
         struct vc_csr4 vmax;
         struct vc_csr4 hmax;
         struct vc_csr4 shs;
-        struct vc_csr2 gain;
+        struct vc_csr2 again;
+        struct vc_csr2 dgain;
         struct vc_csr2 blacklevel;
         struct vc_csr2 h_start;
         struct vc_csr2 v_start;
@@ -208,7 +209,8 @@ struct vc_ctrl {
         // Controls
         struct vc_mode mode[MAX_VC_MODES];
         struct vc_control exposure;
-        struct vc_gain gain;
+        struct vc_gain again;
+        struct vc_gain dgain;
         struct vc_control framerate;
         // Modes & Frame Formats
         struct vc_frame frame;          // Pixel
@@ -266,7 +268,7 @@ int vc_write_i2c_reg(struct i2c_client *client, const __u16 addr, const __u8 val
 struct i2c_client *vc_mod_get_client(struct device *dev, struct i2c_adapter *adapter, __u8 i2c_addr);
 
 // --- Helper functions for internal data structures --------------------------
-void vc_core_print_debug(struct vc_cam *cam); // Only used by NVIDIA driver
+void vc_core_print_debug(struct vc_cam *cam);                                   // Only used by NVIDIA driver
 struct device *vc_core_get_sen_device(struct vc_cam *cam);
 vc_mode vc_core_get_mode(struct vc_cam *cam);
 int vc_core_enum_mbus_code(struct vc_cam *cam, __u32 index);
@@ -278,30 +280,32 @@ int vc_core_set_num_lanes(struct vc_cam *cam, __u32 number);
 __u32 vc_core_get_num_lanes(struct vc_cam *cam);
 int vc_core_set_framerate(struct vc_cam *cam, __u32 framerate);
 __u32 vc_core_get_framerate(struct vc_cam *cam);
-__u32 vc_core_get_time_per_line_ns(struct vc_cam *cam); // Only used by NXP driver
+__u32 vc_core_get_time_per_line_ns(struct vc_cam *cam);                         // Only used by NXP driver
 int vc_core_set_binning_mode(struct vc_cam *cam, int mode);
+__u64 vc_core_mdB_to_times(int mdB);                                              // Only used by NXP driver
+int vc_core_times_to_mdB(__u64 times);                                            // Only used by NXP driver
 #ifdef ENABLE_ADVANCED_CONTROL
-int vc_core_set_hmax_overwrite(struct vc_cam *cam, __s32 hmax_overwrite); // Only used by NXP driver
-int vc_core_set_vmax_overwrite(struct vc_cam *cam, __s32 vmax_overwrite); // Only used by NXP driver
-int vc_core_set_height_offset(struct vc_cam *cam, __s32 vmax_overwrite); // Only used by NXP driver
+int vc_core_set_hmax_overwrite(struct vc_cam *cam, __s32 hmax_overwrite);       // Only used by NXP driver
+int vc_core_set_vmax_overwrite(struct vc_cam *cam, __s32 vmax_overwrite);       // Only used by NXP driver
+int vc_core_set_height_offset(struct vc_cam *cam, __s32 vmax_overwrite);        // Only used by NXP driver
 #endif
 
 // --- Function to initialize the vc core --------------------------------------
 int vc_core_init(struct vc_cam *cam, struct i2c_client *client);
 int vc_core_release(struct vc_cam *cam);
-int vc_core_update_controls(struct vc_cam *cam); // Only used by NVIDIA driver
+int vc_core_update_controls(struct vc_cam *cam);                                // Only used by NVIDIA driver
 
 // --- Functions for the VC MIPI Controller Module ----------------------------
 int vc_mod_set_mode(struct vc_cam *cam, int *reset);
 int vc_mod_set_trigger_mode(struct vc_cam *cam, int mode);
-int vc_mod_get_trigger_mode(struct vc_cam *cam); // Only used by NVIDIA driver
+int vc_mod_get_trigger_mode(struct vc_cam *cam);                                // Only used by NVIDIA driver
 int vc_mod_set_single_trigger(struct vc_cam *cam);
 int vc_mod_set_io_mode(struct vc_cam *cam, int mode);
 
 // --- Functions for the VC MIPI Sensors --------------------------------------
 int vc_sen_set_roi(struct vc_cam *cam);
 int vc_sen_set_exposure(struct vc_cam *cam, int exposure);
-int vc_sen_set_gain(struct vc_cam *cam, int gain);
+int vc_sen_set_gain(struct vc_cam *cam, __u64 gain, bool unit_is_mdB);
 int vc_sen_set_blacklevel(struct vc_cam *cam, __u32 blacklevel);
 int vc_sen_start_stream(struct vc_cam *cam);
 int vc_sen_stop_stream(struct vc_cam *cam);
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
index 71279ef..8466116 100644
--- a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
@@ -6,22 +6,25 @@
         struct device *dev = &ctrl->client_mod->dev; \
         vc_notice(dev, "%s(): Initialising module control for %s\n", __FUNCTION__, camera);
 
-#define GAIN_LIN(_max, _max_mdB) \
-        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+#define AGAIN_LIN(_max, _max_mdB) \
+        ctrl->again = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
         .type = GAIN_LINEAR};
 
-#define GAIN_LOG(_max, _max_mdB, _c0, _c1) \
-        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+#define AGAIN_LOG(_max, _max_mdB, _c0, _c1) \
+        ctrl->again = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
         .type = GAIN_LOGARITHMIC, .c0 = _c0, .c1 = _c1 };
 
-#define GAIN_REC(_max, _max_mdB, _c0, _c1) \
-        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+#define AGAIN_REC(_max, _max_mdB, _c0, _c1) \
+        ctrl->again = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
         .type = GAIN_RECIPROCAL, .c0 = _c0, .c1 = _c1 };
 
-#define GAIN_FRA(_max, _max_mdB) \
-        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+#define AGAIN_FRA(_max, _max_mdB) \
+        ctrl->again = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
         .type = GAIN_FRACTIONAL};
 
+#define DGAIN(_max, _max_mdB) \
+        ctrl->dgain = (vc_gain) { .max = _max, .max_mdB = _max_mdB };
+
 #define FRAME(_left, _top, _width, _height) \
         ctrl->frame = (vc_frame) { .left = _left, .top = _top, .width = _width, .height = _height };
 
@@ -71,8 +74,8 @@ static void vc_init_ctrl(struct vc_ctrl *ctrl, struct vc_desc* desc)
         ctrl->csr.sen.shs.h             = desc->csr_exposure_h;
         ctrl->csr.sen.shs.u             = 0;
         
-        ctrl->csr.sen.gain.l            = desc->csr_gain_l;
-        ctrl->csr.sen.gain.m            = desc->csr_gain_h;
+        ctrl->csr.sen.again.l            = desc->csr_gain_l;
+        ctrl->csr.sen.again.m            = desc->csr_gain_h;
 
         ctrl->csr.sen.h_start.l         = desc->csr_h_start_l;
         ctrl->csr.sen.h_start.m         = desc->csr_h_start_h;
@@ -108,7 +111,7 @@ static void vc_init_ctrl_imx183_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
 static void vc_init_ctrl_imx252_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0210, .m = 0x0211, .h = 0x0212, .u = 0x0000 };
         ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x0214, .m = 0x0215, .h = 0x0000, .u = 0x0000 };
@@ -123,7 +126,7 @@ static void vc_init_ctrl_imx252_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
 static void vc_init_ctrl_imx290_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
-        GAIN_LIN(240, 72000)
+        AGAIN_LIN(240, 72000)
         
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3018, .m = 0x3019, .h = 0x301A, .u = 0x0000 };
         ctrl->csr.sen.mode_standby      = 0x01;
@@ -141,7 +144,7 @@ static void vc_init_ctrl_imx290_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
 static void vc_init_ctrl_imx296_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
         
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3010, .m = 0x3011, .h = 0x3012, .u = 0x0000 };
         ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x300A };
@@ -165,7 +168,7 @@ static void vc_init_ctrl_imx178(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
         vc_init_ctrl_imx183_base(ctrl, desc);
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3015, .m = 0x3016 };
 
@@ -192,7 +195,7 @@ static void vc_init_ctrl_imx183(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
         vc_init_ctrl_imx183_base(ctrl, desc);
 
-        GAIN_LOG(1957, 27000, 2048, 2048)
+        AGAIN_LOG(1957, 27000, 2048, 2048)
         
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
 
@@ -217,7 +220,7 @@ static void vc_init_ctrl_imx226(struct vc_ctrl *ctrl, struct vc_desc* desc)
 
         vc_init_ctrl_imx183_base(ctrl, desc);
 
-        GAIN_LOG(1957, 27000, 2048, 2048)
+        AGAIN_LOG(1957, 27000, 2048, 2048)
         
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
 
@@ -423,7 +426,7 @@ static void vc_init_ctrl_imx335(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX335")
 
-        GAIN_LIN(240, 72000)
+        AGAIN_LIN(240, 72000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3302, .m = 0x3303 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3030, .m = 0x3031, .h = 0x3032, .u = 0x0000 };
@@ -487,10 +490,11 @@ static void vc_init_ctrl_imx412(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX412")
         
-        GAIN_REC(978, 13400, 1024, 1024)
+        AGAIN_REC(978, 13400, 1024, 1024)
+        DGAIN(0x0fff, 12000);
 
+        ctrl->csr.sen.dgain             = (vc_csr2) { .l = 0x020f, .m = 0x020e };
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3033, .m = 0x3032 };
-
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0341, .m = 0x0340, .h = 0x0000, .u = 0x0000 };
         ctrl->csr.sen.shs               = (vc_csr4) { .l = 0x0203, .m = 0x0202, .h = 0x0000, .u = 0x0000 };
 
@@ -570,7 +574,7 @@ static void vc_init_ctrl_imx415(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX415")
         
-        GAIN_LIN(240, 72000)
+        AGAIN_LIN(240, 72000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x30e2, .m = 0x30e3 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3024, .m = 0x3025, .h = 0x3026, .u = 0x0000 };
@@ -631,9 +635,9 @@ static void vc_init_ctrl_imx565(struct vc_ctrl *ctrl, struct vc_desc *desc)
 {
         INIT_MESSAGE("IMX565")
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
         
-        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x3514, .m = 0x3515 };
+        ctrl->csr.sen.again             = (vc_csr2) { .l = 0x3514, .m = 0x3515 };
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
         ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x30d8, .m = 0x30d9, .h = 0x0000, .u = 0x0000 };
@@ -697,7 +701,7 @@ static void vc_init_ctrl_imx566(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX566")
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
@@ -762,7 +766,7 @@ static void vc_init_ctrl_imx567(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX567")
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
@@ -832,7 +836,7 @@ static void vc_init_ctrl_imx568(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX568")
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
@@ -896,7 +900,7 @@ static void vc_init_ctrl_imx900(struct vc_ctrl *ctrl, struct vc_desc* desc)
 {
         INIT_MESSAGE("IMX900")
 
-        GAIN_LIN(480, 48000)
+        AGAIN_LIN(480, 48000)
 
         ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
@@ -941,7 +945,7 @@ static void vc_init_ctrl_ov7251(struct vc_ctrl *ctrl, struct vc_desc* desc)
         INIT_MESSAGE("OV7251")
 
         ctrl->exposure                  = (vc_control) { .min =   1, .max =   1000000, .def =  10000 };
-        GAIN_FRA(255, 12000)
+        AGAIN_FRA(255, 12000)
 
         ctrl->csr.sen.h_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
         ctrl->csr.sen.v_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
@@ -949,7 +953,7 @@ static void vc_init_ctrl_ov7251(struct vc_ctrl *ctrl, struct vc_desc* desc)
         ctrl->csr.sen.flash_offset      = (vc_csr4) { .l = 0x3b8b, .m = 0x3b8a, .h = 0x3b89, .u = 0x3b88 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
         // NOTE: Modules rom table contains swapped address assigment.
-        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x350b, .m = 0x350a };
+        ctrl->csr.sen.again             = (vc_csr2) { .l = 0x350b, .m = 0x350a };
         
         FRAME(0, 0, 640, 480)
         // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
@@ -973,7 +977,7 @@ static void vc_init_ctrl_ov9281(struct vc_ctrl *ctrl, struct vc_desc* desc)
         INIT_MESSAGE("OV9281")
         
         ctrl->exposure                  = (vc_control) { .min = 146, .max =    595000, .def =  10000 };
-        GAIN_FRA(255, 12000)
+        AGAIN_FRA(255, 12000)
 
         ctrl->csr.sen.h_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
         ctrl->csr.sen.v_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
@@ -981,7 +985,7 @@ static void vc_init_ctrl_ov9281(struct vc_ctrl *ctrl, struct vc_desc* desc)
         ctrl->csr.sen.flash_offset      = (vc_csr4) { .l = 0x3924, .m = 0x3923, .h = 0x3922, .u = 0x0000 };
         ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
         // NOTE: Modules rom table contains swapped address assigment.
-        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x3509, .m = 0x0000 };
+        ctrl->csr.sen.again             = (vc_csr2) { .l = 0x3509, .m = 0x0000 };
         
         FRAME(0, 0, 1280, 800)
         // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
-- 
2.25.1

