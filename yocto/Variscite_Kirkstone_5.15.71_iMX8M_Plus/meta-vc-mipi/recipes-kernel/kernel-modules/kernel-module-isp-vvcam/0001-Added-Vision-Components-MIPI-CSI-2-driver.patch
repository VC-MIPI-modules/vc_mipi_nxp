From b1fde2a7e20545a19315940bdb0b0b2f513c53a3 Mon Sep 17 00:00:00 2001
From: Peter Martienssen <peter.martienssen@liquify-consulting.de>
Date: Mon, 19 Aug 2024 12:46:44 +0200
Subject: [PATCH 1/4] Added Vision Components MIPI CSI-2 driver

---
 build-all-vvcam.sh                            |    1 +
 vvcam/v4l2/sensor/Makefile                    |    1 +
 vvcam/v4l2/sensor/vc-mipi-vvcam/Makefile      |    3 +
 .../sensor/vc-mipi-vvcam/vc_mipi_camera.c     | 1027 ++++++++
 .../v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c  | 2130 +++++++++++++++++
 .../v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h  |  306 +++
 .../sensor/vc-mipi-vvcam/vc_mipi_modules.c    | 1036 ++++++++
 .../sensor/vc-mipi-vvcam/vc_mipi_modules.h    |   34 +
 8 files changed, 4538 insertions(+)
 create mode 100644 vvcam/v4l2/sensor/vc-mipi-vvcam/Makefile
 create mode 100644 vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
 create mode 100755 vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
 create mode 100755 vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
 create mode 100644 vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
 create mode 100644 vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.h

diff --git a/build-all-vvcam.sh b/build-all-vvcam.sh
index 7a5e77f..f74e372 100755
--- a/build-all-vvcam.sh
+++ b/build-all-vvcam.sh
@@ -46,3 +46,4 @@ cp vvcam/v4l2/sensor/os08a20/os08a20.ko modules
 cp vvcam/v4l2/vvcam-isp.ko modules
 cp vvcam/v4l2/video/vvcam-video.ko modules
 cp vvcam/v4l2/sensor/camera-proxy-driver/basler-camera-driver-vvcam.ko modules
+cp vvcam/v4l2/sensor/vc-mipi-vvcam/vc-mipi-vvcam.ko modules
diff --git a/vvcam/v4l2/sensor/Makefile b/vvcam/v4l2/sensor/Makefile
index 61a69ff..a6adf75 100755
--- a/vvcam/v4l2/sensor/Makefile
+++ b/vvcam/v4l2/sensor/Makefile
@@ -2,4 +2,5 @@ obj-m += ov2775/
 obj-m += os08a20/
 obj-m += camera-proxy-driver/
 obj-m += ar1335/
+obj-m += vc-mipi-vvcam/
 
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/Makefile b/vvcam/v4l2/sensor/vc-mipi-vvcam/Makefile
new file mode 100644
index 0000000..eef08ed
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/Makefile
@@ -0,0 +1,3 @@
+EXTRA_CFLAGS += -I$(PWD)/../common/ -O2 -Werror
+vc-mipi-vvcam-objs += vc_mipi_camera.o vc_mipi_core.o vc_mipi_modules.o
+obj-m += vc-mipi-vvcam.o
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
new file mode 100644
index 0000000..5ec8dd4
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_camera.c
@@ -0,0 +1,1027 @@
+#include "vc_mipi_core.h"
+#include <linux/module.h>
+// #include <linux/gpio/consumer.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+// #define ENABLE_PM    // support for power management
+#ifdef ENABLE_PM
+#include <linux/pm_runtime.h>
+#endif
+#define ENABLE_VVCAM // support for Vivante ISP API
+#ifdef ENABLE_VVCAM
+#include "vvsensor.h"
+#endif
+
+#define VERSION "0.3.0"
+
+#define V4L2_CID_CSI_LANES      (V4L2_CID_LASTP1 + 0)
+#define V4L2_CID_TRIGGER_MODE   (V4L2_CID_LASTP1 + 1)
+#define V4L2_CID_IO_MODE        (V4L2_CID_LASTP1 + 2)
+#define V4L2_CID_FRAME_RATE     (V4L2_CID_LASTP1 + 3)
+#define V4L2_CID_SINGLE_TRIGGER (V4L2_CID_LASTP1 + 4)
+#define V4L2_CID_BINNING_MODE   (V4L2_CID_LASTP1 + 5)
+#ifdef ENABLE_ADVANCED_CONTROL
+#define V4L2_CID_HMAX_OVERWRITE (V4L2_CID_LASTP1 + 6)
+#define V4L2_CID_VMAX_OVERWRITE (V4L2_CID_LASTP1 + 7)
+#define V4L2_CID_HEIGHT_OFFSET  (V4L2_CID_LASTP1 + 8)
+#endif
+
+struct vc_device {
+        unsigned int csi_id;
+        struct v4l2_subdev sd;
+        struct v4l2_ctrl_handler ctrl_handler;
+        struct media_pad pad;
+        // struct gpio_desc *power_gpio;
+        int power_on;
+        struct mutex mutex;
+
+        struct vc_cam cam;
+};
+
+static inline struct vc_device *to_vc_device(struct v4l2_subdev *sd)
+{
+        return container_of(sd, struct vc_device, sd);
+}
+
+static inline struct vc_cam *to_vc_cam(struct v4l2_subdev *sd)
+{
+        struct vc_device *device = to_vc_device(sd);
+        return &device->cam;
+}
+
+
+// --- v4l2_subdev_core_ops ---------------------------------------------------
+
+static void vc_set_power(struct vc_device *device, int on)
+{
+        struct device *dev = &device->cam.ctrl.client_sen->dev;
+
+        if (device->power_on == on)
+                return;
+
+        vc_dbg(dev, "%s(): Set power: %s\n", __func__, on ? "on" : "off");
+
+        // if (device->power_gpio)
+        // 	gpiod_set_value_cansleep(device->power_gpio, on);
+
+        // if (on == 1) {
+        //         vc_core_wait_until_device_is_ready(&device->cam, 1000);
+        // }
+        device->power_on = on;
+}
+
+static int vc_sd_s_power(struct v4l2_subdev *sd, int on)
+{
+        struct vc_device *device = to_vc_device(sd);
+
+        mutex_lock(&device->mutex);
+
+        vc_set_power(to_vc_device(sd), on);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+#ifdef ENABLE_PM
+static int __maybe_unused vc_suspend(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_state *state = &device->cam.state;
+
+        vc_dbg(dev, "%s()\n", __func__);
+
+        mutex_lock(&device->mutex);
+
+        if (state->streaming)
+                vc_sen_stop_stream(&device->cam);
+
+        vc_set_power(device, 0);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+static int __maybe_unused vc_resume(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+
+        vc_dbg(dev, "%s()\n", __func__);
+
+        mutex_lock(&device->mutex);
+
+        vc_set_power(device, 1);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+#endif
+
+static const s64 ctrl_csi_lanes_menu[] = {
+	1, 2, 4
+};
+
+static int vc_sd_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)
+{
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        switch (control->id) {
+        case V4L2_CID_EXPOSURE:
+                return vc_sen_set_exposure(cam, control->value);
+
+        case V4L2_CID_GAIN:
+                return vc_sen_set_gain(cam, control->value);
+        
+        case V4L2_CID_CSI_LANES:
+                return vc_core_set_num_lanes(cam, ctrl_csi_lanes_menu[control->value]);
+
+        case V4L2_CID_BLACK_LEVEL:
+                return vc_sen_set_blacklevel(cam, control->value);
+
+        case V4L2_CID_TRIGGER_MODE:
+                return vc_mod_set_trigger_mode(cam, control->value);
+
+        case V4L2_CID_IO_MODE:
+                return vc_mod_set_io_mode(cam, control->value);
+
+        case V4L2_CID_FRAME_RATE:
+                return vc_core_set_framerate(cam, control->value);
+
+        case V4L2_CID_SINGLE_TRIGGER:
+                return vc_mod_set_single_trigger(cam);
+
+        case V4L2_CID_BINNING_MODE:
+                return vc_core_set_binning_mode(cam, control->value);
+
+#ifdef ENABLE_ADVANCED_CONTROL
+        case V4L2_CID_HMAX_OVERWRITE:
+                return vc_core_set_hmax_overwrite(cam, control->value);
+
+        case V4L2_CID_VMAX_OVERWRITE:
+                return vc_core_set_vmax_overwrite(cam, control->value);
+        
+        case V4L2_CID_HEIGHT_OFFSET:
+                return vc_core_set_height_offset(cam, control->value);
+#endif
+
+        default:
+                vc_warn(dev, "%s(): Unknown control 0x%08x\n", __func__, control->id);
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+// --- v4l2_subdev_video_ops ---------------------------------------------------
+
+static int vc_sd_s_stream(struct v4l2_subdev *sd, int enable)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct vc_state *state = &cam->state;
+        struct device *dev = sd->dev;
+        int reset = 0;
+        int ret = 0;
+
+        vc_notice(dev, "%s(): Set streaming: %s\n", __func__, enable ? "on" : "off");
+
+        if (state->streaming == enable)
+                return 0;
+
+        mutex_lock(&device->mutex);
+        if (enable) {
+#ifdef ENABLE_PM
+                ret = pm_runtime_get_sync(dev);
+                if (ret < 0) {
+                        pm_runtime_put_noidle(dev);
+                        mutex_unlock(&device->mutex);
+                        return ret;
+                }
+#endif
+
+                ret  = vc_mod_set_mode(cam, &reset);
+                ret |= vc_sen_set_roi(cam);
+                if (!ret && reset) {
+                        ret |= vc_sen_set_exposure(cam, cam->state.exposure);
+                        ret |= vc_sen_set_gain(cam, cam->state.gain);
+                        ret |= vc_sen_set_blacklevel(cam, cam->state.blacklevel);
+                }
+
+                ret = vc_sen_start_stream(cam);
+                if (ret) {
+                        enable = 0;
+                        vc_sen_stop_stream(cam);
+#ifdef ENABLE_PM
+                        pm_runtime_mark_last_busy(dev);
+                        pm_runtime_put_autosuspend(dev);
+#endif
+                }
+
+        } else {
+                vc_sen_stop_stream(cam);
+#ifdef ENABLE_PM
+                pm_runtime_mark_last_busy(dev);
+                pm_runtime_put_autosuspend(dev);
+#endif
+        }
+
+        state->streaming = enable;
+        mutex_unlock(&device->mutex);
+
+        return ret;
+}
+
+// --- v4l2_subdev_pad_ops ---------------------------------------------------
+
+int vc_sd_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_state *state, struct v4l2_subdev_mbus_code_enum *code)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        __u32 mbus_code = 0;
+
+        mutex_lock(&device->mutex);
+
+        mbus_code = vc_core_enum_mbus_code(cam, code->index);
+        if (mbus_code == -EINVAL) {
+                return -EINVAL;
+        }
+        code->code = mbus_code;
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+static int vc_sd_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *state, struct v4l2_subdev_format *format)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct v4l2_mbus_framefmt *mf = &format->format;
+        struct vc_frame* frame = NULL;
+
+        mutex_lock(&device->mutex);
+
+        frame = vc_core_get_frame(cam);
+        mf->width       = frame->width;
+        mf->height      = frame->height;
+        mf->code        = vc_core_get_format(cam);
+        mf->colorspace  = V4L2_COLORSPACE_SRGB;
+        mf->field       = V4L2_FIELD_NONE;
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+static int vc_sd_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *state, struct v4l2_subdev_format *format)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct vc_frame *frame = vc_core_get_frame(cam);
+        struct v4l2_mbus_framefmt *mf = &format->format;
+
+        mutex_lock(&device->mutex);
+
+        if (mf->code != 0) {
+                vc_core_set_format(cam, mf->code);
+                vc_core_set_frame(cam, frame->left, frame->top, mf->width, mf->height);
+        }
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+int vc_sd_get_selection(struct v4l2_subdev *sd, struct v4l2_subdev_state *state, struct v4l2_subdev_selection *sel)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct vc_frame *frame = vc_core_get_frame(cam);
+        struct vc_frame *frame_bounds = &cam->ctrl.frame;
+
+        mutex_lock(&device->mutex);
+
+        switch (sel->target) {
+        case V4L2_SEL_TGT_CROP:
+                sel->r.left = frame->left;
+                sel->r.top = frame->top;
+                sel->r.width = frame->width;
+                sel->r.height = frame->height;
+                break;
+        case V4L2_SEL_TGT_CROP_DEFAULT:
+        case V4L2_SEL_TGT_CROP_BOUNDS:
+                sel->r.left = frame_bounds->left;
+                sel->r.top = frame_bounds->top;
+                sel->r.width = frame_bounds->width;
+                sel->r.height = frame_bounds->height;
+                break;
+        }
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+int vc_sd_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_state *state, struct v4l2_subdev_selection *sel)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+
+        mutex_lock(&device->mutex);
+
+        switch (sel->target) {
+        case V4L2_SEL_TGT_CROP:
+                vc_core_set_frame(cam, sel->r.left, sel->r.top, sel->r.width, sel->r.height);
+                break;
+        }
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+
+// --- v4l2_ctrl_ops ---------------------------------------------------
+
+int vc_ctrl_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+        struct vc_device *device = container_of(ctrl->handler, struct vc_device, ctrl_handler);
+        struct v4l2_control control;
+#ifdef ENABLE_PM
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+
+        V4L2 controls values will be applied only when power is already up
+        if (!pm_runtime_get_if_in_use(&client->dev))
+        	return 0;
+#endif
+
+        mutex_lock(&device->mutex);
+
+        control.id = ctrl->id;
+        control.value = ctrl->val;
+        vc_sd_s_ctrl(&device->sd, &control);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+#ifdef ENABLE_VVCAM
+// --- Vivante Sensor IOCTL ---------------------------------------------------
+
+static int vc_vidioc_querycap(struct vc_device *device, void *arg)
+{
+        struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+        strcpy((char *)pcap->driver, "vc-mipi-vvcam");
+        sprintf((char *)pcap->bus_info, "csi%d", device->csi_id);
+        pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = (__u8)device->cam.ctrl.client_sen->adapter->nr;
+
+        return 0;
+}
+
+// #define DEBUG_MODE_INFO
+static void vc_get_mode_info(struct vc_device *device, struct vvcam_mode_info_s *info)
+{
+        struct vc_cam *cam = &device->cam;
+#ifdef DEBUG_MODE_INFO
+        struct device *dev = vc_core_get_sen_device(cam);
+#endif
+        struct vc_frame *frame = vc_core_get_frame(cam);
+        struct vc_mode mode = vc_core_get_mode(cam);
+        __u32 num_lanes = vc_core_get_num_lanes(cam);
+        __u32 code = vc_core_get_format(cam);
+        __u32 time_per_line_ns = vc_core_get_time_per_line_ns(cam);
+        __u32 framerate = vc_core_get_framerate(cam);
+
+        // Required infos for streaming
+        info->index = 0;
+        info->hdr_mode = SENSOR_MODE_LINEAR;
+        info->data_compress.enable = 0;
+        info->mipi_info.mipi_lane = num_lanes;
+
+        info->size.left = 0;
+        info->size.top = 0;
+        info->size.width = frame->width;
+        info->size.height = frame->height;
+        info->size.bounds_width = frame->width;
+        info->size.bounds_height = frame->height;
+
+        switch (code) {
+        case MEDIA_BUS_FMT_Y8_1X8:
+        case MEDIA_BUS_FMT_SRGGB8_1X8:
+                info->bit_width = 8;
+                info->bayer_pattern = BAYER_RGGB;
+                break;
+        case MEDIA_BUS_FMT_SGBRG8_1X8:
+                info->bit_width = 8;
+                info->bayer_pattern = BAYER_GBRG;
+                break;
+        case MEDIA_BUS_FMT_Y10_1X10:
+        case MEDIA_BUS_FMT_SRGGB10_1X10:
+                info->bit_width = 10;
+                info->bayer_pattern = BAYER_RGGB;
+                break;
+        case MEDIA_BUS_FMT_SGBRG10_1X10:
+                info->bit_width = 10;
+                info->bayer_pattern = BAYER_GBRG;
+                break;
+        case MEDIA_BUS_FMT_Y12_1X12:
+        case MEDIA_BUS_FMT_SRGGB12_1X12:
+                info->bit_width = 12;
+                info->bayer_pattern = BAYER_RGGB;
+                break;
+        case MEDIA_BUS_FMT_SGBRG12_1X12:
+                info->bit_width = 12;
+                info->bayer_pattern = BAYER_GBRG;
+                break;
+        case MEDIA_BUS_FMT_Y14_1X14:
+        case MEDIA_BUS_FMT_SRGGB14_1X14:
+                info->bit_width = 14;
+                info->bayer_pattern = BAYER_RGGB;
+                break;
+        case MEDIA_BUS_FMT_SGBRG14_1X14:
+                info->bit_width = 14;
+                info->bayer_pattern = BAYER_GBRG;
+                break;
+        }
+        
+        // Required infos for auto exposure control
+        info->ae_info.one_line_exp_time_ns  = time_per_line_ns;
+        info->ae_info.max_integration_line  = (__u64)1000000000000 / framerate / time_per_line_ns;
+        info->ae_info.min_integration_line  = mode.vmax.min;
+        info->ae_info.def_frm_len_lines     = 0;
+        info->ae_info.curr_frm_len_lines    = 0;
+        info->ae_info.start_exposure        = 0;
+
+        info->ae_info.max_again             = cam->ctrl.gain.max_mdB;           // mdB
+        info->ae_info.min_again             = 1;                                // mdB
+        info->ae_info.max_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mdB 
+        info->ae_info.min_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mdB
+        
+        info->ae_info.cur_fps               = framerate;                        // mHz
+        info->ae_info.max_fps               = cam->ctrl.framerate.max;          // mHz
+        info->ae_info.min_fps               = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mHz
+        info->ae_info.min_afps              = 1 * (1 << SENSOR_FIX_FRACBITS);   // 1024 mHz
+
+        info->ae_info.int_update_delay_frm  = 1;
+        info->ae_info.gain_update_delay_frm = 1;
+
+#ifdef DEBUG_MODE_INFO
+        vc_info(dev, "%s(): ------------------------------------------\n", __func__);
+        vc_info(dev, "%s(): size.left:            %5u px\n", __func__, info->size.left);
+        vc_info(dev, "%s(): size.top:             %5u px\n", __func__, info->size.top);
+        vc_info(dev, "%s(): size.width:           %5u px\n", __func__, info->size.width);
+        vc_info(dev, "%s(): size.height:          %5u px\n", __func__, info->size.height);
+        vc_info(dev, "%s(): ------------------------------------------\n", __func__);
+        vc_info(dev, "%s(): one_line_exp_time_ns: %5u ns\n", __func__, info->ae_info.one_line_exp_time_ns);
+        vc_info(dev, "%s(): max_integration_line: %5u lines\n", __func__, info->ae_info.max_integration_line);
+        vc_info(dev, "%s(): min_integration_line: %5u lines\n", __func__, info->ae_info.min_integration_line);
+        vc_info(dev, "%s(): def_frm_len_lines:    %5u lines\n", __func__, info->ae_info.def_frm_len_lines);
+        vc_info(dev, "%s(): curr_frm_len_lines:   %5u lines\n", __func__, info->ae_info.curr_frm_len_lines);
+        vc_info(dev, "%s(): start_exposure:       %5u lines\n", __func__, info->ae_info.start_exposure);
+        vc_info(dev, "%s(): ------------------------------------------\n", __func__);
+        vc_info(dev, "%s(): max_again:            %5u mdB\n", __func__, info->ae_info.max_again);
+        vc_info(dev, "%s(): ------------------------------------------\n", __func__);
+        vc_info(dev, "%s(): cur_fps:              %5u mHz\n", __func__, info->ae_info.cur_fps);
+        vc_info(dev, "%s(): max_fps:              %5u mHz\n", __func__, info->ae_info.max_fps);
+        vc_info(dev, "%s(): min_fps:              %5u mHz\n", __func__, info->ae_info.min_fps);
+        vc_info(dev, "%s(): min_afps:             %5u mHz\n", __func__, info->ae_info.min_afps);
+        vc_info(dev, "%s(): ------------------------------------------\n", __func__);
+#endif
+}
+
+static int vc_vvsensorioc_query(struct vc_device *device, struct vvcam_mode_info_array_s *mode_info)
+{
+        vc_get_mode_info(device, &mode_info->modes[0]);
+        mode_info->count = 1;
+        return 0;
+}
+
+static int vc_vvsensorioc_g_sensor_mode(struct vc_device *device, struct vvcam_mode_info_s *mode)
+{
+        vc_get_mode_info(device, mode);
+        return 0;
+}
+
+static long vc_sd_vvsensorioc(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        long ret = 0;
+
+        switch (cmd){
+        // Required cases for streaming
+        case VIDIOC_QUERYCAP:
+                ret = vc_vidioc_querycap(device, arg);
+                vc_dbg(sd->dev, "%s(): VIDIOC_QUERYCAP\n", __func__);
+                break;
+        case VVSENSORIOC_QUERY:
+                ret = vc_vvsensorioc_query(device, arg);
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_QUERY\n", __func__);
+                break;
+        case VVSENSORIOC_G_SENSOR_MODE:
+                ret = vc_vvsensorioc_g_sensor_mode(device, arg);
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_G_SENSOR_MODE [index: %u]\n", __func__,
+                        ((struct vvcam_mode_info_s *)arg)->index);
+                break;
+        case VVSENSORIOC_S_STREAM:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_STREAM [%u]\n", __func__, *(u32 *)arg);
+                ret = vc_sd_s_stream(sd, *(int *)arg);
+                break;
+
+        // Required cases for auto exposure control
+        case VVSENSORIOC_S_EXP:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_EXP [%u]\n", __func__, *(u32 *)arg);
+                ret = vc_sen_set_exposure(&device->cam, ((*(u32 *)arg) * vc_core_get_time_per_line_ns(cam)) / 1000);
+                break;
+        case VVSENSORIOC_S_GAIN:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_GAIN [%u]\n", __func__, *(u32 *)arg);
+                ret = vc_sen_set_gain(&device->cam, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_S_FPS:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_FPS [%u]\n", __func__, *(u32 *)arg);
+                // NOTE: Diese Funktion wird nicht mehr aufgerufen. 
+                // ret = vc_core_set_framerate(&device->cam, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_G_FPS:
+                *(u32 *)arg = vc_core_get_framerate(&device->cam);
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_G_FPS [%u]\n", __func__, *(u32 *)arg);
+                break;
+
+        // Not implemented but called cases
+        case VVSENSORIOC_RESET:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_RESET [%u] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_S_POWER:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_POWER [%u] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_S_CLK:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_CLK [%lu] (not implemented)\n", __func__, 
+                        ((struct vvcam_clk_s*)arg)->sensor_mclk);
+                break;
+        case VVSENSORIOC_G_CLK:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_G_CLK [%lu] (not implemented)\n", __func__,
+                        ((struct vvcam_clk_s*)arg)->sensor_mclk);
+                break;
+        case VVSENSORIOC_G_RESERVE_ID:
+                *(u32 *)arg = 0;
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_G_RESERVE_ID [0x%04x] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_G_CHIP_ID:
+                *(u32 *)arg = 0;
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_G_CHIP_ID [0x%04x] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_S_SENSOR_MODE:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_SENSOR_MODE [index: %u] (not implemented)\n", __func__,
+                        ((struct vvcam_mode_info_s *)arg)->index);
+                break;
+        case VVSENSORIOC_S_HDR_RADIO:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_HDR_RADIO [%u] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        case VVSENSORIOC_S_TEST_PATTERN:
+                vc_dbg(sd->dev, "%s(): VVSENSORIOC_S_TEST_PATTERN [%u] (not implemented)\n", __func__, *(u32 *)arg);
+                break;
+        default:
+                vc_dbg(sd->dev, "%s(): invalid IOCTL 0x%x\n", __func__, cmd);
+                break;
+        }
+
+        return ret;
+}
+#endif
+
+// *** Initialisation *********************************************************
+
+// static void vc_setup_power_gpio(struct vc_device *device)
+// {
+//         struct device *dev = &device->cam.ctrl.client_sen->dev;
+
+//         device->power_gpio = devm_gpiod_get_optional(dev, "power", GPIOD_OUT_HIGH);
+//         if (IS_ERR(device->power_gpio)) {
+//                 vc_err(dev, "%s(): Failed to setup power-gpio\n", __func__);
+//                 device->power_gpio = NULL;
+//         }
+// }
+
+static int vc_check_hwcfg(struct vc_device *device, struct device *dev)
+{
+        struct vc_cam *cam = &device->cam;
+        struct fwnode_handle *endpoint;
+        struct v4l2_fwnode_endpoint ep_cfg = {
+                .bus_type = V4L2_MBUS_CSI2_DPHY
+        };
+        int ret = -EINVAL;
+
+        ret = of_property_read_u32(dev->of_node, "csi_id", &(device->csi_id));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+        endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+        if (!endpoint) {
+                dev_err(dev, "Endpoint node not found!\n");
+                return -EINVAL;
+        }
+
+        if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {
+                dev_err(dev, "Could not parse endpoint!\n");
+                goto error_out;
+        }
+
+        /* Set and check the number of MIPI CSI2 data lanes */
+        ret = vc_core_set_num_lanes(cam, ep_cfg.bus.mipi_csi2.num_data_lanes);;
+
+error_out:
+        v4l2_fwnode_endpoint_free(&ep_cfg);
+        fwnode_handle_put(endpoint);
+
+        return ret;
+}
+
+static const struct v4l2_subdev_core_ops vc_core_ops = {
+        .s_power = vc_sd_s_power,
+#ifdef ENABLE_VVCAM
+        .ioctl = vc_sd_vvsensorioc,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops vc_video_ops = {
+        .s_stream = vc_sd_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops vc_pad_ops = {
+        .enum_mbus_code = vc_sd_enum_mbus_code,
+        .get_fmt = vc_sd_get_fmt,
+        .set_fmt = vc_sd_set_fmt,
+        .get_selection = vc_sd_get_selection,
+        .set_selection = vc_sd_set_selection
+};
+
+static const struct v4l2_subdev_ops vc_subdev_ops = {
+        .core = &vc_core_ops,
+        .video = &vc_video_ops,
+        .pad = &vc_pad_ops,
+};
+
+static const struct v4l2_ctrl_ops vc_ctrl_ops = {
+        .s_ctrl = vc_ctrl_s_ctrl,
+};
+
+static int vc_ctrl_init_ctrl(struct vc_device *device, struct v4l2_ctrl_handler *hdl, int id, int min, int max, int def)
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        struct v4l2_ctrl *ctrl;
+
+        ctrl = v4l2_ctrl_new_std(&device->ctrl_handler, &vc_ctrl_ops, id, min, max, 1, def);
+        if (ctrl == NULL) {
+                vc_err(dev, "%s(): Failed to init 0x%08x ctrl\n", __func__, id);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+static int vc_ctrl_init_custom_ctrl(struct vc_device *device, struct v4l2_ctrl_handler *hdl, const struct v4l2_ctrl_config *config)
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        struct v4l2_ctrl *ctrl;
+
+        ctrl = v4l2_ctrl_new_custom(&device->ctrl_handler, config, NULL);
+        if (ctrl == NULL) {
+                vc_err(dev, "%s(): Failed to init 0x%08x ctrl\n", __func__, config->id);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+static const struct v4l2_ctrl_config ctrl_csi_lanes = {
+	.ops = &vc_ctrl_ops,
+	.id = V4L2_CID_CSI_LANES,
+	.name = "CSI Lanes",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = ARRAY_SIZE(ctrl_csi_lanes_menu) - 1,
+	.def = 2,
+	.qmenu_int = ctrl_csi_lanes_menu,
+};
+
+static const struct v4l2_ctrl_config ctrl_black_level = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_BLACK_LEVEL,
+        .name = "Black Level",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 100000,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_trigger_mode = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_TRIGGER_MODE,
+        .name = "Trigger Mode",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 7,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_io_mode = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_IO_MODE,
+        .name = "IO Mode",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_frame_rate = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_FRAME_RATE,
+        .name = "Frame Rate",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 1000000,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_single_trigger = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_SINGLE_TRIGGER,
+        .name = "Single Trigger",
+        .type = V4L2_CTRL_TYPE_BUTTON,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_binning_mode = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_BINNING_MODE,
+        .name = "Binning Mode",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = 0,
+        .max = 4,
+        .step = 1,
+        .def = 0,
+};
+
+#ifdef ENABLE_ADVANCED_CONTROL
+static const struct v4l2_ctrl_config ctrl_hmax_overwrite = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_HMAX_OVERWRITE,
+        .name = "hmax Overwrite",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = -1,
+        .max = 10000,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_vmax_overwrite = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_VMAX_OVERWRITE,
+        .name = "vmax Overwrite",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = -1,
+        .max = 10000,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_height_offset = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_HEIGHT_OFFSET,
+        .name = "Height Offset",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+        .min = -10000,
+        .max = 10000,
+        .step = 1,
+        .def = 0,
+};
+#endif
+
+static int vc_sd_init(struct vc_device *device)
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        int ret;
+
+        // Initializes the subdevice
+        v4l2_i2c_subdev_init(&device->sd, client, &vc_subdev_ops);
+
+        // Initialize the handler
+        ret = v4l2_ctrl_handler_init(&device->ctrl_handler, 3);
+        if (ret) {
+                vc_err(dev, "%s(): Failed to init control handler\n", __func__);
+                return ret;
+        }
+        // Hook the control handler into the driver
+        device->sd.ctrl_handler = &device->ctrl_handler;
+
+        // Add controls
+        ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_EXPOSURE, 
+                device->cam.ctrl.exposure.min, device->cam.ctrl.exposure.max,
+                device->cam.ctrl.exposure.def);
+        ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_GAIN, 
+                0, device->cam.ctrl.gain.max_mdB, 0);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_csi_lanes);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_black_level);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_trigger_mode);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_io_mode);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_frame_rate);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_single_trigger);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_binning_mode);
+#ifdef ENABLE_ADVANCED_CONTROL
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_hmax_overwrite);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_vmax_overwrite);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_height_offset);
+#endif
+
+        return 0;
+}
+
+static int vc_link_setup(struct media_entity *entity, const struct media_pad *local, const struct media_pad *remote,
+                         __u32 flags)
+{
+        return 0;
+}
+
+static const struct media_entity_operations vc_sd_media_ops = {
+        .link_setup = vc_link_setup,
+};
+
+static int vc_probe(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        struct vc_device *device;
+        struct vc_cam *cam;
+        int ret;
+
+        vc_notice(dev, "%s(): Probing UNIVERSAL VC MIPI Driver (v%s)\n", __func__, VERSION);
+
+        device = devm_kzalloc(dev, sizeof(*device), GFP_KERNEL);
+        if (!device)
+                return -ENOMEM;
+
+        cam = &device->cam;
+        cam->ctrl.client_sen = client;
+
+        // vc_setup_power_gpio(device);
+        vc_set_power(device, 1);
+
+        ret = vc_core_init(cam, client);
+        if (ret)
+                goto error_power_off;
+
+        ret = vc_check_hwcfg(device, dev);
+        if (ret)
+                goto error_power_off;
+
+        mutex_init(&device->mutex);
+        ret = vc_sd_init(device);
+        if (ret)
+                goto error_handler_free;
+
+        device->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+        device->pad.flags = MEDIA_PAD_FL_SOURCE;
+        device->sd.entity.ops = &vc_sd_media_ops;
+        device->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+        ret = media_entity_pads_init(&device->sd.entity, 1, &device->pad);
+        if (ret)
+                goto error_handler_free;
+
+        ret = v4l2_async_register_subdev_sensor(&device->sd);
+        if (ret)
+                goto error_media_entity;
+
+#ifdef ENABLE_PM
+        pm_runtime_get_noresume(dev);
+        pm_runtime_set_active(dev);
+        pm_runtime_enable(dev);
+        pm_runtime_set_autosuspend_delay(dev, 2000);
+        pm_runtime_use_autosuspend(dev);
+        pm_runtime_mark_last_busy(dev);
+        pm_runtime_put_autosuspend(dev);
+#endif
+
+        return 0;
+
+error_media_entity:
+        media_entity_cleanup(&device->sd.entity);
+
+error_handler_free:
+        v4l2_ctrl_handler_free(&device->ctrl_handler);
+        mutex_destroy(&device->mutex);
+
+error_power_off:
+#ifdef ENABLE_PM
+        pm_runtime_disable(dev);
+        pm_runtime_set_suspended(dev);
+        pm_runtime_put_noidle(dev);
+#endif
+        vc_set_power(device, 0);
+        vc_core_release(&device->cam);
+        return ret;
+}
+
+static int vc_remove(struct i2c_client *client)
+{
+        struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+
+        v4l2_async_unregister_subdev(&device->sd);
+        media_entity_cleanup(&device->sd.entity);
+        v4l2_ctrl_handler_free(&device->ctrl_handler);
+#ifdef ENABLE_PM
+        pm_runtime_disable(&client->dev);
+#endif
+        mutex_destroy(&device->mutex);
+
+#ifdef ENABLE_PM
+        pm_runtime_get_sync(&client->dev);
+        pm_runtime_disable(&client->dev);
+        pm_runtime_set_suspended(&client->dev);
+        pm_runtime_put_noidle(&client->dev);
+#endif
+
+        vc_set_power(device, 0);
+        vc_core_release(&device->cam);
+
+        return 0;
+}
+
+#ifdef ENABLE_PM
+static const struct dev_pm_ops vc_pm_ops = {
+        SET_SYSTEM_SLEEP_ENABLE_PM_OPS(vc_suspend, vc_resume)
+};
+#endif
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id vc_acpi_ids[] = {
+        {"VCMIPICAM"},
+        {}
+};
+
+MODULE_DEVICE_TABLE(acpi, vc_acpi_ids);
+#endif
+
+static const struct i2c_device_id vc_id[] = {
+        { "vc-mipi-cam", 0 },
+        { /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, vc_id);
+
+static const struct of_device_id vc_dt_ids[] = {
+        { .compatible = "vc,vc_mipi" },
+        { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, vc_dt_ids);
+
+static struct i2c_driver vc_i2c_driver = {
+        .driver = {
+                .name = "vc-mipi-cam",
+#ifdef ENABLE_PM
+                .pm = &vc_pm_ops,
+#endif
+                .acpi_match_table = ACPI_PTR(vc_acpi_ids),
+                .of_match_table = vc_dt_ids,
+        },
+        .id_table = vc_id,
+        .probe_new = vc_probe,
+        .remove   = vc_remove,
+};
+
+module_i2c_driver(vc_i2c_driver);
+
+MODULE_VERSION(VERSION);
+MODULE_DESCRIPTION("Vision Components GmbH - VC MIPI CSI-2 driver");
+MODULE_AUTHOR("Peter Martienssen, Liquify Consulting <peter.martienssen@liquify-consulting.de>");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
new file mode 100755
index 0000000..48a6e91
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.c
@@ -0,0 +1,2130 @@
+#include "vc_mipi_core.h"
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/v4l2-mediabus.h>
+#include  <linux/kernel.h>
+#include "vc_mipi_modules.h"
+
+// #define READ_DEFAULT_REG_VALUES
+
+#define MOD_REG_RESET            0x0100 // register  0 [0x0100]: reset and init register (R/W)
+#define MOD_REG_STATUS           0x0101 // register  1 [0x0101]: status (R)
+#define MOD_REG_MODE             0x0102 // register  2 [0x0102]: initialisation mode (R/W)
+#define MOD_REG_IOCTRL           0x0103 // register  3 [0x0103]: input/output control (R/W)
+#define MOD_REG_MOD_ADDR         0x0104 // register  4 [0x0104]: module i2c address (R/W, default: 0x10)
+#define MOD_REG_SEN_ADDR         0x0105 // register  5 [0x0105]: sensor i2c address (R/W, default: 0x1A)
+#define MOD_REG_OUTPUT           0x0106 // register  6 [0x0106]: output signal override register (R/W, default: 0x00)
+#define MOD_REG_INPUT            0x0107 // register  7 [0x0107]: input signal status register (R)
+#define MOD_REG_EXTTRIG          0x0108 // register  8 [0x0108]: external trigger enable (R/W, default: 0x00)
+#define MOD_REG_EXPO_L           0x0109 // register  9 [0x0109]: exposure LSB (R/W, default: 0x10)
+#define MOD_REG_EXPO_M           0x010A // register 10 [0x010A]: exposure 	   (R/W, default: 0x27)
+#define MOD_REG_EXPO_H           0x010B // register 11 [0x010B]: exposure     (R/W, default: 0x00)
+#define MOD_REG_EXPO_U           0x010C // register 12 [0x010C]: exposure MSB (R/W, default: 0x00)
+#define MOD_REG_RETRIG_L         0x010D // register 13 [0x010D]: retrigger LSB (R/W, default: 0x40)
+#define MOD_REG_RETRIG_M         0x010E // register 14 [0x010E]: retrigger     (R/W, default: 0x2D)
+#define MOD_REG_RETRIG_H         0x010F // register 15 [0x010F]: retrigger     (R/W, default: 0x29)
+#define MOD_REG_RETRIG_U         0x0110 // register 16 [0x0110]: retrigger MSB (R/W, default: 0x00)
+
+#define REG_RESET_PWR_UP         0x00
+#define REG_RESET_SENSOR         0x01   // reg0[0] = 0 sensor reset the sensor is held in reset when this bit is 1
+#define REG_RESET_PWR_DOWN       0x02   // reg0[1] = 0 power down power for the sensor is switched off
+#define REG_STATUS_NO_COM        0x00   // reg1[7:0] = 0x00 default, no communication with sensor possible
+#define REG_STATUS_READY         0x80   // reg1[7:0] = 0x80 sensor ready after successful initialization sequence
+#define REG_STATUS_ERROR         0x01   // reg1[7:0] = 0x01 internal error during initialization
+
+#define REG_IO_DISABLE           0x00
+#define REG_IO_FLASH_ENABLE      0x01
+#define REG_IO_XTRIG_ENABLE      0x08
+#define REG_IO_FLASH_ACTIVE_LOW  0x10
+#define REG_IO_TRIG_ACTIVE_LOW   0x40
+
+#define REG_TRIGGER_DISABLE      0x00
+#define REG_TRIGGER_EXTERNAL     0x01
+#define REG_TRIGGER_PULSEWIDTH   0x02
+#define REG_TRIGGER_SELF         0x04
+#define REG_TRIGGER_SINGLE       0x08
+#define REG_TRIGGER_SYNC         0x10
+#define REG_TRIGGER_STREAM_EDGE  0x20
+#define REG_TRIGGER_STREAM_LEVEL 0x60
+
+#define MODE_TYPE_STREAM         0x01
+#define MODE_TYPE_TRIGGER        0x02
+#define MODE_TYPE_SLAVE          0x03
+
+// ------------------------------------------------------------------------------------------------
+// Function prototypes
+
+struct device *vc_core_get_mod_device(struct vc_cam *cam);
+int vc_core_try_format(struct vc_cam *cam, __u32 code);
+__u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
+static __u32 vc_core_calculate_period_1H(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning);
+void vc_core_calculate_roi(struct vc_cam *cam, __u32 *w_left, __u32 *w_right, __u32 *w_width,
+        __u32 *w_top, __u32 *w_bottom, __u32 *w_height, __u32 *o_width, __u32 *o_height);
+static int vc_sen_read_image_size(struct vc_ctrl *ctrl, struct vc_frame *size);
+struct vc_binning *vc_core_get_binning(struct vc_cam *cam);
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for I2C Communication
+
+#define U_BYTE(value) (__u8)((value >> 24) & 0xff)
+#define H_BYTE(value) (__u8)((value >> 16) & 0xff)
+#define M_BYTE(value) (__u8)((value >>  8) & 0xff)
+#define L_BYTE(value) (__u8)((value >>  0) & 0xff)
+
+static __u8 i2c_read_reg(struct device *dev, struct i2c_client *client, const __u16 addr, const char* func)
+{
+        __u8 buf[2] = { addr >> 8, addr & 0xff };
+        int ret;
+        struct i2c_msg msgs[] = {
+                {
+                        .addr = client->addr,
+                        .flags = 0,
+                        .len = 2,
+                        .buf = buf,
+                },
+                {
+                        .addr = client->addr,
+                        .flags = I2C_M_RD,
+                        .len = 1,
+                        .buf = buf,
+                },
+        };
+
+        ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+        if (ret < 0) {
+                vc_err(&client->dev, "%s(): Reading register 0x%04x from 0x%02x failed\n", func, addr, client->addr);
+                return ret;
+        }
+
+        vc_dbg(dev, "%s():   addr: 0x%04x => value: 0x%02x\n", func, addr, buf[0]);
+
+        return buf[0];
+}
+
+static int i2c_write_reg(struct device *dev, struct i2c_client *client, const __u16 addr, const __u8 value, const char* func)
+{
+        struct i2c_adapter *adap = client->adapter;
+        struct i2c_msg msg;
+        __u8 tx[3];
+        int ret;
+
+        vc_dbg(dev, "%s():   addr: 0x%04x <= value: 0x%02x\n", func, addr, value);
+
+        msg.addr = client->addr;
+        msg.buf = tx;
+        msg.len = 3;
+        msg.flags = 0;
+        tx[0] = addr >> 8;
+        tx[1] = addr & 0xff;
+        tx[2] = value;
+        ret = i2c_transfer(adap, &msg, 1);
+
+        return ret == 1 ? 0 : -EIO;
+}
+
+int i2c_write_regs(struct i2c_client *client, const struct vc_reg *regs, const char* func)
+{
+        int i;
+
+        if (regs == NULL)
+                return -EINVAL;
+
+        for (i = 0; regs[i].address != 0; i++) {
+                i2c_write_reg(&client->dev, client, regs[i].address, regs[i].value, func);
+        }
+
+        return 0;
+}
+
+static __u32 i2c_read_reg2(struct device *dev, struct i2c_client *client, struct vc_csr2 *csr, const char* func)
+{
+        __u32 reg = 0;
+        __u32 value = 0;
+
+        reg = i2c_read_reg(dev, client, csr->l, func);
+        if (reg)
+                value |= (0x000000ff & reg);
+        reg = i2c_read_reg(dev, client, csr->m, func);
+        if (reg)
+                value |= (0x000000ff & reg) <<  8;
+
+        return value;
+}
+
+static int i2c_write_reg2(struct device *dev, struct i2c_client *client, struct vc_csr2 *csr, const __u16 value, const char* func)
+{
+        int ret = 0;
+
+        if (csr->l)
+                ret  = i2c_write_reg(dev, client, csr->l, L_BYTE(value), func);
+        if (csr->m)
+                ret |= i2c_write_reg(dev, client, csr->m, M_BYTE(value), func);
+
+        return ret;
+}
+
+#ifdef READ_DEFAULT_REG_VALUES
+static __u32 i2c_read_reg4(struct device *dev, struct i2c_client *client, struct vc_csr4 *csr, const char* func)
+{
+        __u32 reg = 0;
+        __u32 value = 0;
+
+        reg = i2c_read_reg(dev, client, csr->l, func);
+        if (reg)
+                value |= (0x000000ff & reg);
+        reg = i2c_read_reg(dev, client, csr->m, func);
+        if (reg)
+                value |= (0x000000ff & reg) <<  8;
+        reg = i2c_read_reg(dev, client, csr->h, func);
+        if (reg)
+                value |= (0x000000ff & reg) << 16;
+        reg = i2c_read_reg(dev, client, csr->u, func);
+        if (reg)
+                value |= (0x000000ff & reg) << 24;
+
+        return value;
+}
+#endif
+
+static int i2c_write_reg4(struct device *dev, struct i2c_client *client, struct vc_csr4 *csr, const __u32 value, const char *func)
+{
+        int ret = 0;
+
+        if (csr->l)
+                ret = i2c_write_reg(dev, client, csr->l, L_BYTE(value), func);
+        if (csr->m)
+                ret |= i2c_write_reg(dev, client, csr->m, M_BYTE(value), func);
+        if (csr->h)
+                ret |= i2c_write_reg(dev, client, csr->h, H_BYTE(value), func);
+        if (csr->u)
+                ret |= i2c_write_reg(dev, client, csr->u, U_BYTE(value), func);
+
+        return ret;
+}
+
+int vc_read_i2c_reg(struct i2c_client *client, const __u16 addr)
+{
+        return i2c_read_reg(&client->dev, client, addr, __FUNCTION__);
+}
+EXPORT_SYMBOL(vc_read_i2c_reg);
+
+int vc_write_i2c_reg(struct i2c_client *client, const __u16 addr, const __u8 value)
+{
+        return i2c_write_reg(&client->dev, client, addr, value, __FUNCTION__);
+}
+EXPORT_SYMBOL(vc_write_i2c_reg);
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for debugging
+
+static void vc_core_print_desc(struct device *dev, struct vc_desc *desc)
+{
+        int is_color = vc_mod_is_color_sensor(desc);
+
+        vc_info(dev, "+--- VC MIPI Camera -----------------------------------+\n");
+        vc_info(dev, "| MANUF. | %s               MID: 0x%04x |\n", desc->manuf, desc->manuf_id);
+        vc_info(dev, "| MODULE | ID:  0x%04x                     REV:   %04u |\n", desc->mod_id, desc->mod_rev);
+        vc_info(dev, "| SENSOR | %s%s %s%s                                |\n", desc->sen_manuf, (0 == strcmp("OM", desc->sen_manuf)) ? "  ":"", desc->sen_type, is_color ? "" : " ");
+        vc_info(dev, "+--------+---------------------------------------------+\n");
+}
+
+static void vc_core_print_csr(struct device *dev, struct vc_desc *desc)
+{
+        vc_info(dev, "+--- Sensor Registers ------+--------+--------+--------+\n");
+        vc_info(dev, "|                           | low    | mid    | high   |\n");
+        vc_info(dev, "+---------------------------+--------+--------+--------+\n");
+        vc_info(dev, "| idle                      | 0x%04x |        |        |\n", desc->csr_mode);
+        vc_info(dev, "| horizontal start          | 0x%04x | 0x%04x |        |\n", desc->csr_h_start_l, desc->csr_h_start_h);
+        vc_info(dev, "| vertical start            | 0x%04x | 0x%04x |        |\n", desc->csr_v_start_l, desc->csr_v_start_h);
+        vc_info(dev, "| horizontal end            | 0x%04x | 0x%04x |        |\n", desc->csr_h_end_l, desc->csr_h_end_h);
+        vc_info(dev, "| vertical end              | 0x%04x | 0x%04x |        |\n", desc->csr_v_end_l, desc->csr_v_end_h);
+        vc_info(dev, "| hor. output width         | 0x%04x | 0x%04x |        |\n", desc->csr_o_width_l, desc->csr_o_width_h);
+        vc_info(dev, "| ver. output height        | 0x%04x | 0x%04x |        |\n", desc->csr_o_height_l, desc->csr_o_height_h);
+        vc_info(dev, "| exposure                  | 0x%04x | 0x%04x | 0x%04x |\n", desc->csr_exposure_l, desc->csr_exposure_m, desc->csr_exposure_h);
+        vc_info(dev, "| gain                      | 0x%04x | 0x%04x |        |\n", desc->csr_gain_l, desc->csr_gain_h);
+        vc_info(dev, "+---------------------------+--------+--------+--------+\n");
+        vc_info(dev, "| clock for ext. trigger    | %8u Hz              |\n", desc->clk_ext_trigger);
+        vc_info(dev, "| pixel clock               | %8u Hz              |\n", desc->clk_pixel);
+        vc_info(dev, "| shutter offset            | %8u us              |\n", desc->shutter_offset);
+        vc_info(dev, "+---------------------------+--------------------------+\n");
+}
+
+static void vc_core_print_format(__u8 format, char *buf)
+{
+        switch (format) {
+        case FORMAT_RAW08: strcpy(buf, "RAW08"); break;
+        case FORMAT_RAW10: strcpy(buf, "RAW10"); break;
+        case FORMAT_RAW12: strcpy(buf, "RAW12"); break;
+        case FORMAT_RAW14: strcpy(buf, "RAW14"); break;
+        default: sprintf(buf, "0x%02x ", format); break;
+        }
+}
+
+static void vc_core_print_modes(struct device *dev, struct vc_desc *desc)
+{
+        struct vc_desc_mode *mode;
+        __u32 data_rate = 0;
+        char format[16], type[16];
+        int index = 0;
+
+        vc_info(dev, "+--- Module Modes -------+---------+---------+---------+\n");
+        vc_info(dev, "|  # | rate    | lanes   | format  | type    | binning |\n");
+        vc_info(dev, "+----+---------+---------+---------+---------+---------+\n");
+        for (index = 0; index<desc->num_modes; index++) {
+                mode = &desc->modes[index];
+                data_rate = (*(__u32*)mode->data_rate)/1000000;
+                vc_core_print_format(mode->format, format);
+                switch (mode->type) {
+                case MODE_TYPE_STREAM:  strcpy(type, "STREAM "); break;
+                case MODE_TYPE_TRIGGER: strcpy(type, "EXT.TRG"); break;
+                case MODE_TYPE_SLAVE:   strcpy(type, "SLAVE  "); break;
+                default: sprintf(type, "0x%02x   ", mode->type); break;
+                }
+                vc_info(dev, "| %2d |    %4u |       %u | %s   | %s |       %u |\n",
+                        index, data_rate, mode->num_lanes, format, type, mode->binning);
+        }
+        vc_info(dev, "+----+---------+---------+---------+---------+---------+\n");
+}
+
+static void vc_core_print_mode(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char sformat[16];
+        int index = 0;
+
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
+                vc_info(dev, "+-------+--------+------------+-----------+\n");
+                vc_info(dev, "| lanes | format | exposure   | framerate |\n");
+                vc_info(dev, "|       |        | max [us]   | max [mHz] |\n");
+                vc_info(dev, "+-------+--------+------------+-----------+\n");
+                while (index < MAX_VC_MODES && ctrl->mode[index].num_lanes != 0) {
+                        __u8 num_lanes = ctrl->mode[index].num_lanes;
+                        __u8 format = ctrl->mode[index].format;
+                        __u8 binning = ctrl->mode[index].binning;
+                        __u32 max_exposure = vc_core_calculate_max_exposure(cam, num_lanes, format, binning);
+                        __u32 max_frame_rate = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning);
+
+                        vc_core_print_format(format, sformat);
+                        vc_info(dev, "|     %1d | %s  | %10d | %9d |\n",
+                                num_lanes, sformat, max_exposure, max_frame_rate);
+                        index++;
+                }
+                vc_info(dev, "+-------+--------+------------+-----------+\n");
+        }
+}
+
+void vc_core_print_debug(struct vc_cam *cam)
+{
+        vc_core_print_mode(cam);
+}
+EXPORT_SYMBOL(vc_core_print_debug);
+
+// ------------------------------------------------------------------------------------------------
+//  Helper functions for internal data structures
+
+struct device *vc_core_get_sen_device(struct vc_cam *cam)
+{
+        return &cam->ctrl.client_sen->dev;
+}
+EXPORT_SYMBOL(vc_core_get_sen_device);
+
+struct device *vc_core_get_mod_device(struct vc_cam *cam)
+{
+        return &cam->ctrl.client_mod->dev;
+}
+
+static int vc_core_get_fourcc_fmt(__u32 code, char *buf)
+{
+        switch(code) {
+        case MEDIA_BUS_FMT_Y8_1X8:       sprintf(buf, "GREY"); break;
+        case MEDIA_BUS_FMT_Y10_1X10:     sprintf(buf, "Y10 "); break;
+        case MEDIA_BUS_FMT_Y12_1X12:     sprintf(buf, "Y12 "); break;
+        case MEDIA_BUS_FMT_Y14_1X14:     sprintf(buf, "Y14 "); break;
+        case MEDIA_BUS_FMT_SRGGB8_1X8:   sprintf(buf, "RGGB"); break;
+        case MEDIA_BUS_FMT_SRGGB10_1X10: sprintf(buf, "RG10"); break;
+        case MEDIA_BUS_FMT_SRGGB12_1X12: sprintf(buf, "RG12"); break;
+        case MEDIA_BUS_FMT_SRGGB14_1X14: sprintf(buf, "RG14"); break;
+        case MEDIA_BUS_FMT_SGBRG8_1X8:   sprintf(buf, "GBRG"); break;
+        case MEDIA_BUS_FMT_SGBRG10_1X10: sprintf(buf, "GB10"); break;
+        case MEDIA_BUS_FMT_SGBRG12_1X12: sprintf(buf, "GB12"); break;
+        case MEDIA_BUS_FMT_SGBRG14_1X14: sprintf(buf, "GB14"); break;
+        default: return -EINVAL;
+        }
+        return 0;
+}
+
+static __u8 vc_core_mbus_code_to_format(__u32 code)
+{
+        switch (code) {
+        case MEDIA_BUS_FMT_Y8_1X8:
+        case MEDIA_BUS_FMT_SRGGB8_1X8:
+        case MEDIA_BUS_FMT_SGBRG8_1X8:
+                return FORMAT_RAW08;
+        case MEDIA_BUS_FMT_Y10_1X10:
+        case MEDIA_BUS_FMT_SRGGB10_1X10:
+        case MEDIA_BUS_FMT_SGBRG10_1X10:
+                return FORMAT_RAW10;
+        case MEDIA_BUS_FMT_Y12_1X12:
+        case MEDIA_BUS_FMT_SRGGB12_1X12:
+        case MEDIA_BUS_FMT_SGBRG12_1X12:
+                return FORMAT_RAW12;
+        case MEDIA_BUS_FMT_Y14_1X14:
+        case MEDIA_BUS_FMT_SRGGB14_1X14:
+        case MEDIA_BUS_FMT_SGBRG14_1X14:
+                return FORMAT_RAW14;
+        }
+        return 0;
+}
+
+static __u32 vc_core_format_to_mbus_code(__u8 format, int is_color, int is_gbrg)
+{
+        switch (format) {
+        case FORMAT_RAW08:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG8_1X8 : MEDIA_BUS_FMT_SRGGB8_1X8) : MEDIA_BUS_FMT_Y8_1X8;
+        case FORMAT_RAW10:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG10_1X10 : MEDIA_BUS_FMT_SRGGB10_1X10) : MEDIA_BUS_FMT_Y10_1X10;
+        case FORMAT_RAW12:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG12_1X12 : MEDIA_BUS_FMT_SRGGB12_1X12) : MEDIA_BUS_FMT_Y12_1X12;
+        case FORMAT_RAW14:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG14_1X14 : MEDIA_BUS_FMT_SRGGB14_1X14) : MEDIA_BUS_FMT_Y14_1X14;
+        }
+        return 0;
+}
+
+vc_mode vc_core_get_mode_by_param(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        struct device *dev = vc_core_get_sen_device(cam);
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        int index = 0;
+        int binning_index = 0;
+        vc_mode tRet;
+
+        memset(&tRet, 0, sizeof(vc_mode));
+
+        binning_index = (ctrl->flags & FLAG_USE_BINNING_INDEX) ? binning : 0;
+
+        for (index = 0; index < MAX_VC_MODES; index++) {
+                if ( (num_lanes == ctrl->mode[index].num_lanes)
+                  && (   format == ctrl->mode[index].format) 
+                  && (  binning_index == ctrl->mode[index].binning)) {
+                        memcpy(&tRet, &ctrl->mode[index], sizeof(vc_mode));
+                        return ctrl->mode[index];
+                  }
+        }
+
+        vc_err(dev, "%s(): Could not get mode values!\n", __FUNCTION__);
+
+        return tRet;
+}
+
+vc_mode vc_core_get_mode(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        return vc_core_get_mode_by_param(cam, state->num_lanes, format, binning);
+}
+EXPORT_SYMBOL(vc_core_get_mode);
+
+__u32 vc_core_get_hmax(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+#ifdef ENABLE_ADVANCED_CONTROL
+        if (cam->state.hmax_overwrite > 0) {
+                return cam->state.hmax_overwrite;
+        }
+#endif
+        return vc_core_get_mode_by_param(cam, num_lanes, format, binning).hmax;
+}
+
+vc_control vc_core_get_vmax(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        return vc_core_get_mode_by_param(cam, num_lanes, format, binning).vmax;
+}
+
+vc_control vc_core_get_blacklevel(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        return vc_core_get_mode_by_param(cam, num_lanes, format, binning).blacklevel;
+}
+
+__u32 vc_core_get_retrigger(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        return vc_core_get_mode_by_param(cam, num_lanes, format, binning).retrigger_min;
+}
+
+#ifdef ENABLE_ADVANCED_CONTROL
+int vc_core_set_hmax_overwrite(struct vc_cam *cam, __s32 hmax_overwrite)
+{
+        struct device *dev = vc_core_get_sen_device(cam);
+        vc_info(dev, "%s(): Set HMAX overwrite: %d\n", __FUNCTION__, hmax_overwrite);
+
+        cam->state.hmax_overwrite = hmax_overwrite;
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_hmax_overwrite);
+
+int vc_core_set_vmax_overwrite(struct vc_cam *cam, __s32 vmax_overwrite)
+{
+        struct device *dev = vc_core_get_sen_device(cam);
+        vc_info(dev, "%s(): Set VMAX overwrite: %d\n", __FUNCTION__, vmax_overwrite);
+
+        cam->state.vmax_overwrite = vmax_overwrite;
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_vmax_overwrite);
+
+int vc_core_set_height_offset(struct vc_cam *cam, __s32 height_offset)
+{
+        struct device *dev = vc_core_get_sen_device(cam);
+        vc_info(dev, "%s(): Set height offset: %d\n", __FUNCTION__, height_offset);
+
+        cam->state.height_offset = height_offset;
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_height_offset);
+
+#endif
+
+static __u32 vc_core_get_default_format(struct vc_cam *cam)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        __u8 format = desc->modes[0].format;
+        int is_color = vc_mod_is_color_sensor(desc);
+        int is_bgrg = ctrl->flags & FLAG_FORMAT_GBRG;
+        return vc_core_format_to_mbus_code(format, is_color, is_bgrg);
+}
+
+int vc_core_enum_mbus_code(struct vc_cam *cam, __u32 index) 
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_desc *desc = &cam->desc;
+        struct device *dev = vc_core_get_sen_device(cam);
+        int is_color = vc_mod_is_color_sensor(desc);
+        int is_bgrg = ctrl->flags & FLAG_FORMAT_GBRG;
+        int modeIx, codeIx;
+
+        if (desc->mbus_codes[0] == 0) {
+                for (modeIx = 0; modeIx < desc->num_modes; modeIx++) {
+                        struct vc_desc_mode *mode = &desc->modes[modeIx];
+                        __u32 code = vc_core_format_to_mbus_code(mode->format, is_color, is_bgrg);
+                        vc_dbg(dev, "%s(): Checking mode %u (code: 0x%04x)\n", __FUNCTION__, modeIx, code);
+
+                        for (codeIx = 0; codeIx < ARRAY_SIZE(desc->mbus_codes); codeIx++) {
+                                if (desc->mbus_codes[codeIx] == 0) {
+                                        desc->mbus_codes[codeIx] = code;
+                                        break;
+                                } 
+                                if (desc->mbus_codes[codeIx] == code) {
+                                        break;
+                                }
+                        }
+                }
+                vc_dbg(dev, "%s(): MBUS codes (0x%04x, 0x%04x, 0x%04x, 0x%04x)\n", __FUNCTION__, 
+                        desc->mbus_codes[0], desc->mbus_codes[1], desc->mbus_codes[2], desc->mbus_codes[3]);
+        }
+
+        return desc->mbus_codes[index];
+}
+EXPORT_SYMBOL(vc_core_enum_mbus_code);
+
+int vc_core_try_format(struct vc_cam *cam, __u32 code)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 format = vc_core_mbus_code_to_format(code);
+        char fourcc[5];
+        int index;
+
+        vc_core_get_fourcc_fmt(code, fourcc);
+        vc_info(dev, "%s(): Try format 0x%04x (%s, format: 0x%02x)\n", __FUNCTION__, code, fourcc, format);
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                vc_dbg(dev, "%s(): Checking mode %u (format: 0x%02x)", __FUNCTION__, index, mode->format);
+                if(mode->format == format) {
+                        return 0;
+                }
+        }
+
+        return -EINVAL;
+}
+
+int vc_core_set_format(struct vc_cam *cam, __u32 code)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        char fourcc[5];
+
+        vc_core_get_fourcc_fmt(code, fourcc);
+        vc_info(dev, "%s(): Set format: 0x%04x (%s)\n", __FUNCTION__, code, fourcc);
+
+        if (vc_core_try_format(cam, code)) {
+                state->format_code = vc_core_get_default_format(cam);
+                vc_core_update_controls(cam);
+                vc_err(dev, "%s(): Format 0x%04x not supported! (Set default format: 0x%04x)\n", __FUNCTION__, code, state->format_code);
+                 return -EINVAL;
+        }
+
+        state->format_code = code;
+        vc_core_update_controls(cam);
+
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_format);
+
+__u32 vc_core_get_format(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 code = state->format_code;
+        char fourcc[5];
+
+        vc_core_get_fourcc_fmt(code, fourcc);
+        vc_info(dev, "%s(): Get format: 0x%04x (%s)\n", __FUNCTION__, code, fourcc);
+
+        return code;
+}
+EXPORT_SYMBOL(vc_core_get_format);
+
+static void vc_core_limit_frame_position(struct vc_cam *cam, __u32 left, __u32 top)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+
+        if (left > ctrl->frame.width - state->frame.width) {
+                state->frame.left = ctrl->frame.width - state->frame.width;
+        } else {
+                state->frame.left = left;
+        }
+
+        if (top > ctrl->frame.height - state->frame.height) {
+                state->frame.top = ctrl->frame.height - state->frame.height;
+        } else {
+                state->frame.top = top;
+        }
+}
+
+static void vc_core_limit_frame_size(struct vc_cam *cam, __u32 width, __u32 height)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+
+        if (width > ctrl->frame.width) {
+                state->frame.width = ctrl->frame.width;
+        } else {
+                state->frame.width = width;
+        }
+
+        if (height > ctrl->frame.height) {
+                state->frame.height = ctrl->frame.height;
+        } else {
+                state->frame.height = height;
+        }
+}
+
+int vc_core_set_frame(struct vc_cam *cam, __u32 left, __u32 top, __u32 width, __u32 height)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_info(dev, "%s(): Set frame (left: %u, top: %u, width: %u, height: %u)\n", __FUNCTION__, left, top, width, height);
+
+        vc_core_limit_frame_size(cam, width, height);
+        vc_core_limit_frame_position(cam, left, top);
+
+        if (state->frame.left != left || state->frame.top != top || state->frame.width != width || state->frame.height != height) {
+                vc_warn(dev, "%s(): Adjusted frame (left: %u, top: %u, width: %u, height: %u)\n", __FUNCTION__,
+                state->frame.left, state->frame.top, state->frame.width, state->frame.height);
+        }
+
+        vc_core_update_controls(cam);
+
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_frame);
+
+struct vc_frame *vc_core_get_frame(struct vc_cam *cam)
+{
+        struct vc_frame* frame = &cam->state.frame;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_info(dev, "%s(): Get frame (width: %u, height: %u)\n", __FUNCTION__, frame->width, frame->height);
+
+        return frame;
+}
+EXPORT_SYMBOL(vc_core_get_frame);
+
+int vc_core_set_num_lanes(struct vc_cam *cam, __u32 number)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 index = 0;
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                if (mode->num_lanes == number) {
+                        vc_info(dev, "%s(): Set number of lanes: %u\n", __FUNCTION__, number);
+                        state->num_lanes = number;
+                        vc_core_update_controls(cam);
+                        return 0;
+                }
+        }
+
+        vc_err(dev, "%s(): Number of lanes %u not supported!\n", __FUNCTION__, number);
+        return -EINVAL;
+}
+EXPORT_SYMBOL(vc_core_set_num_lanes);
+
+__u32 vc_core_get_num_lanes(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_dbg(dev, "%s(): Get number of lanes: %u\n", __FUNCTION__, state->num_lanes);
+        return state->num_lanes;
+}
+EXPORT_SYMBOL(vc_core_get_num_lanes);
+
+int vc_core_set_framerate(struct vc_cam *cam, __u32 framerate)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_info(dev, "%s(): Set framerate: %u mHz\n", __FUNCTION__, framerate);
+
+        if (framerate < ctrl->framerate.min) {
+                framerate = ctrl->framerate.min;
+        }
+        if (framerate > ctrl->framerate.max) {
+                framerate = ctrl->framerate.max;
+        }
+        state->framerate = framerate;
+
+        return vc_sen_set_exposure(cam, cam->state.exposure);
+}
+EXPORT_SYMBOL(vc_core_set_framerate);
+
+__u32 vc_core_get_framerate(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 framerate = 0;
+
+        if (state->framerate > 0) {
+                framerate = state->framerate;
+        } else {
+                framerate = ctrl->framerate.max;
+        }
+
+        vc_info(dev, "%s(): Get framerate: %u mHz\n", __FUNCTION__, framerate);
+        return framerate;
+}
+EXPORT_SYMBOL(vc_core_get_framerate);
+
+__u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        __u32 vmax_max = vc_core_get_vmax(cam, num_lanes, format, binning).max;
+        __u32 vmax_min = vc_core_get_vmax(cam, num_lanes, format, binning).min;
+
+        switch (cam->state.trigger_mode) {
+        case REG_TRIGGER_DISABLE:
+        case REG_TRIGGER_SYNC:
+        case REG_TRIGGER_STREAM_EDGE:
+        case REG_TRIGGER_STREAM_LEVEL:
+        default:
+                {
+                        __u32 period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format, binning);
+                        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax.max: %u, vmax.min: %u\n",
+                                __FUNCTION__, period_1H_ns, vmax_max, vmax_min);
+                        return ((__u64)period_1H_ns * (vmax_max - vmax_min)) / 1000;
+                }
+        case REG_TRIGGER_EXTERNAL:
+        case REG_TRIGGER_PULSEWIDTH:
+        case REG_TRIGGER_SELF:
+        case REG_TRIGGER_SINGLE:
+                {
+                        vc_dbg(dev, "%s(): clk_ext_trigger: %u\n", __FUNCTION__, ctrl->clk_ext_trigger);
+                        return ((__u64)0xffffffff * 1000000) / ctrl->clk_ext_trigger;
+                }
+        }
+}
+
+__u32 vc_core_get_optimized_vmax(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning_mode = state->binning_mode;
+        __u32 vmax_def = vc_core_get_vmax(cam, num_lanes, format, binning_mode).def;
+        struct vc_binning *binning = vc_core_get_binning(cam);
+        __u32 height = state->frame.height;
+        __u32 vmax_res = vmax_def;
+
+        if ( 0 == vmax_def) {
+                return vmax_def;
+        }
+
+        if (binning->v_factor > 0) {
+                height = state->frame.height * binning->v_factor;
+        }
+
+        // Increase the frame rate when image height is reduced.
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE && height < ctrl->frame.height) {
+                vmax_res = vmax_def - (ctrl->frame.height - height);
+                vc_dbg(dev, "%s(): Increased frame rate: vmax %u/%u, height: %u/%u, vmax result: %u \n", __FUNCTION__,
+                        state->vmax, vmax_def, state->frame.height, ctrl->frame.height, vmax_res);
+
+                return vmax_res;
+        }
+
+        return vmax_def;
+}
+
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format, binning);
+        __u32 vmax = vc_core_get_optimized_vmax(cam);
+        __u32 vmax_def = vc_core_get_vmax(cam, num_lanes, format, binning).def;
+
+        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax: %u/%u\n",
+                __FUNCTION__, period_1H_ns, vmax, vmax_def);
+
+        return 1000000000 / (((__u64)period_1H_ns * vmax) / 1000);
+}
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for the VC MIPI Controller Module
+
+struct i2c_client *vc_mod_get_client(struct device *dev, struct i2c_adapter *adapter, __u8 i2c_addr)
+{
+        struct i2c_client *client;
+        struct i2c_board_info info = {
+                I2C_BOARD_INFO("i2c", i2c_addr),
+        };
+        unsigned short addr_list[2] = { i2c_addr, I2C_CLIENT_END };
+        int count;
+
+        for (count = 0; count < 200; count++) {
+                msleep(1);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,5,0)
+                client = i2c_new_probed_device(adapter, &info, addr_list, NULL);
+                if (client != NULL) {
+                        vc_dbg(dev, "%s(): %u attempts took %u ms to probe i2c device 0x%02x\n", __func__, count, count, i2c_addr);
+                        return client;
+                }
+#else
+                client = i2c_new_scanned_device(adapter, &info, addr_list, NULL);
+                if (!IS_ERR(client)) {
+                        vc_dbg(dev, "%s(): %u attempts took %u ms to scan i2c device 0x%02x\n", __func__, count, count, i2c_addr);
+                        return client;
+                } 
+#endif
+        }
+
+        // How to change the drivers name.
+        // i2c 6-0010
+        //  ^     ^
+        //  |     +--- The device name is set by
+        //  |          i2c_new_probed_device() -> i2c_new_device() -> i2c_dev_set_name()
+        //  |          dev_set_name() and dev_name()
+        //  +---------
+        // dev = &client->dev;
+        // vc_info(dev, "%s(): dev_name:%s\n", __FUNCTION__, dev_name(dev));
+        // if (dev->driver == 0) {
+        // 	vc_err(dev, "%s(): dev->driver == 0\n", __FUNCTION__);
+        // }
+
+        return NULL;
+}
+EXPORT_SYMBOL(vc_mod_get_client);
+
+int vc_mod_set_power(struct vc_cam *cam, int on)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &client_mod->dev;
+        int ret;
+
+        vc_info(dev, "%s(): Set module power: %s\n", __FUNCTION__, on ? "up" : "down");
+
+        ret = i2c_write_reg(dev, client_mod, MOD_REG_RESET, on ? REG_RESET_PWR_UP : REG_RESET_PWR_DOWN, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Unable to power %s the module (error: %d)\n", __FUNCTION__,
+                        (on == REG_RESET_PWR_UP) ? "up" : "down", ret);
+                cam->state.power_on = 0;
+                return ret;
+        }
+
+        cam->state.power_on = on;
+        return 0;
+}
+
+static int vc_mod_read_status(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        ret = i2c_read_reg(dev, client, MOD_REG_STATUS, __FUNCTION__);
+        if (ret < 0)
+                vc_err(dev, "%s(): Unable to get module status (error: %d)\n", __FUNCTION__, ret);
+        else
+                vc_dbg(dev, "%s(): Get module status: 0x%02x\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_write_trigger_mode(struct i2c_client *client, int mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write trigger mode: 0x%02x\n", __FUNCTION__, mode);
+
+        ret = i2c_write_reg(dev, client, MOD_REG_EXTTRIG, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write external trigger (error: %d)\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_write_io_mode(struct i2c_client *client, int mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write IO mode: %s\n", __FUNCTION__, mode ? "ON" : "OFF");
+
+        ret = i2c_write_reg(dev, client, MOD_REG_IOCTRL, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write IO mode (error: %d)\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_wait_until_module_is_ready(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        int status;
+        int try;
+
+        vc_dbg(dev, "%s(): Wait until module is ready\n", __FUNCTION__);
+
+        status = REG_STATUS_NO_COM;
+        try = 0;
+        while (status == REG_STATUS_NO_COM && try < 10) {
+                usleep_range(200000, 200000);
+                status = vc_mod_read_status(client);
+                try++;
+        }
+        if (status == REG_STATUS_ERROR) {
+                vc_err(dev, "%s(): Internal Error!", __func__);
+                return -EIO;
+        }
+
+        vc_dbg(dev, "%s(): Module is ready!\n", __FUNCTION__);
+        return 0;
+}
+
+static int vc_mod_setup(struct vc_ctrl *ctrl, int mod_i2c_addr, struct vc_desc *desc)
+{
+        struct i2c_client *client_sen = ctrl->client_sen;
+        struct i2c_adapter *adapter = client_sen->adapter;
+        struct device *dev_sen = &client_sen->dev;
+        struct i2c_client *client_mod;
+        struct device *dev_mod;
+        int addr, reg;
+
+        vc_dbg(dev_sen, "%s(): Setup the module\n", __FUNCTION__);
+
+        if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+                vc_err(dev_sen, "%s(): I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n", __FUNCTION__);
+                return 0;
+        }
+
+        client_mod = vc_mod_get_client(dev_sen, adapter, mod_i2c_addr);
+        if (client_mod == 0) {
+                vc_err(dev_sen, "%s(): Unable to get module I2C client for address 0x%02x\n", __FUNCTION__, mod_i2c_addr);
+                return -EIO;
+        }
+
+        dev_mod = &client_mod->dev;
+        for (addr = 0; addr < sizeof(*desc); addr++) {
+                reg = i2c_read_reg(dev_mod, client_mod, addr + 0x1000, __FUNCTION__);
+                if (reg < 0) {
+                        i2c_unregister_device(client_mod);
+                        return -EIO;
+                }
+                *((char *)(desc) + addr) = (char)reg;
+        }
+
+        // TODO: Check if connected module is really a VC MIPI module
+        vc_core_print_desc(dev_mod, desc);
+        vc_core_print_csr(dev_mod, desc);
+        vc_core_print_modes(dev_mod, desc);
+
+        ctrl->client_mod = client_mod;
+        ctrl->mod_i2c_addr = mod_i2c_addr;
+
+        if (desc->num_modes == 0) {
+                vc_err(dev_mod, "%s(): Could not find any module modes! Operation not possible!\n", __FUNCTION__);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+int vc_core_update_controls(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
+                ctrl->exposure.max = vc_core_calculate_max_exposure(cam, num_lanes, format, binning);
+                ctrl->framerate.max = vc_core_calculate_max_frame_rate(cam, num_lanes, format, binning);
+
+                vc_dbg(dev, "%s(): num_lanes: %u, format %u, exposure.max: %u us, framerate.max: %u mHz\n",
+                        __FUNCTION__, num_lanes, format, ctrl->exposure.max, ctrl->framerate.max);
+        }
+
+        return 0;
+}
+
+static void vc_core_state_init(struct vc_cam *cam)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        __u8 format = 0;
+        __u32 blacklevel_def = 0;
+        __u32 blacklevel_max = 0;
+        __u8 binning = state->binning_mode;
+
+        state->mode = 0xff;
+        state->exposure = ctrl->exposure.def;
+        state->gain = 0;
+        state->shs = 0;
+        state->vmax = 0;
+        state->exposure_cnt = 0;
+        state->retrigger_cnt = 0;
+        state->framerate = ctrl->framerate.def;
+        state->num_lanes = desc->modes[0].num_lanes;
+        state->format_code = vc_core_get_default_format(cam);
+        format = vc_core_mbus_code_to_format(state->format_code);
+        blacklevel_def = vc_core_get_blacklevel(cam, state->num_lanes, format, binning).def;
+        blacklevel_max = vc_core_get_blacklevel(cam, state->num_lanes, format, binning).max + 1;
+        state->blacklevel = (__u32)DIV_ROUND_CLOSEST(blacklevel_def * 100000, blacklevel_max);
+
+        state->frame.left = 0;
+        state->frame.top = 0;
+        state->frame.width = ctrl->frame.width;
+        state->frame.height = ctrl->frame.height;
+        state->streaming = 0;
+        state->flags = 0x00;
+
+#ifdef ENABLE_ADVANCED_CONTROL
+        state->hmax_overwrite = 0;
+        state->vmax_overwrite = 0;
+        state->height_offset = 0;
+#endif
+}
+
+int vc_core_init(struct vc_cam *cam, struct i2c_client *client)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        int ret;
+
+        ctrl->client_sen = client;
+        ret = vc_mod_setup(ctrl, 0x10, desc);
+        if (ret) {
+                return -EIO;
+        }
+        ret = vc_mod_ctrl_init(ctrl, desc);
+        if (ret) {
+                return -EIO;
+        }
+        if (ctrl->frame.width == 0 || ctrl->frame.height == 0) {
+                vc_sen_read_image_size(ctrl, &ctrl->frame);
+        }
+
+        vc_core_state_init(cam);
+        vc_core_update_controls(cam);
+        vc_core_print_mode(cam);
+
+        vc_info(&ctrl->client_mod->dev, "VC MIPI Core successfully initialized");
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_init);
+
+int vc_core_release(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        i2c_unregister_device(ctrl->client_mod);
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_release);
+
+static int vc_mod_write_exposure(struct i2c_client *client, __u32 value)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module exposure = 0x%08x (%u)\n", __FUNCTION__, value, value);
+
+        ret  = i2c_write_reg(dev, client, MOD_REG_EXPO_L, L_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_M, M_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_H, H_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_U, U_BYTE(value), __FUNCTION__);
+
+        return ret;
+}
+
+static int vc_mod_write_retrigger(struct i2c_client *client, __u32 value)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module retrigger = 0x%08x (%u)\n", __FUNCTION__, value, value);
+
+        ret  = i2c_write_reg(dev, client, MOD_REG_RETRIG_L, L_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_M, M_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_H, H_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_U, U_BYTE(value), __FUNCTION__);
+
+        return ret;
+}
+
+static __u8 vc_mod_find_mode(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 type, __u8 binning)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct device *dev = vc_core_get_mod_device(cam);
+        __u8 index = 0, mode_index = 0;
+        __u32 data_rate = 0, max_data_rate = 0;
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                data_rate = (*(__u32*)mode->data_rate)/1000000;
+
+                vc_dbg(dev, "%s(): Checking mode (#%02u, data_rate: %u, lanes: %u, format: 0x%02x, type: 0x%02x, binning: 0x%02x)",
+                        __FUNCTION__, index, data_rate, mode->num_lanes, mode->format, mode->type, mode->binning);
+                if(mode->num_lanes == num_lanes &&
+                   mode->format == format &&
+                   mode->type == type &&
+                   mode->binning == binning &&
+                   data_rate > max_data_rate) {
+                        max_data_rate = data_rate;
+                        mode_index = index;
+                }
+        }
+        return mode_index;
+}
+
+static int vc_mod_write_mode(struct i2c_client *client, __u8 mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module mode: 0x%02x\n", __FUNCTION__, mode);
+
+        ret = i2c_write_reg(dev, client, MOD_REG_MODE, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write module mode: 0x%02x (error: %d)\n", __FUNCTION__, mode, ret);
+
+        return ret;
+}
+
+int vc_mod_reset_module(struct vc_cam *cam, __u8 mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client = ctrl->client_mod;
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Reset the module!\n", __FUNCTION__);
+
+        ret = vc_mod_set_power(cam, 0);
+        ret |= vc_mod_write_mode(client, mode);
+        ret |= vc_mod_set_power(cam, 1);
+        ret |= vc_mod_wait_until_module_is_ready(client);
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_mod_reset_module);
+
+#ifdef READ_DEFAULT_REG_VALUES
+static __u32 vc_sen_read_hmax(struct vc_ctrl *ctrl)
+{
+	struct i2c_client *client = ctrl->client_sen;
+	struct device *dev = &client->dev;
+	__u32 hmax = i2c_read_reg4(dev, client, &ctrl->csr.sen.hmax, __FUNCTION__);
+
+	vc_info(dev, "%s(): Read sensor HMAX: 0x%08x (%u)\n", __FUNCTION__, hmax, hmax);
+
+	return hmax;
+}
+
+static __u32 vc_sen_read_vmax(struct vc_ctrl *ctrl)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        __u32 vmax = i2c_read_reg4(dev, client, &ctrl->csr.sen.vmax, __FUNCTION__);
+
+        vc_info(dev, "%s(): Read sensor VMAX: 0x%08x (%u)\n", __FUNCTION__, vmax, vmax);
+
+        return vmax;
+}
+#endif
+
+int vc_mod_set_mode(struct vc_cam *cam, int *reset)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        char fourcc[5];
+        char *stype;
+        __u8 type = 0;
+        __u8 binning = 0;
+        __u8 mode = 0;
+        int ret = 0;
+        bool reset_binning = false;
+
+        switch (cam->state.trigger_mode) {
+        case REG_TRIGGER_DISABLE:
+        case REG_TRIGGER_STREAM_EDGE:
+        case REG_TRIGGER_STREAM_LEVEL:
+        default:
+                type = MODE_TYPE_STREAM;
+                stype = "STREAM";
+                break;
+        case REG_TRIGGER_SYNC:
+                if (cam->ctrl.flags & FLAG_TRIGGER_SLAVE) {
+                        type = MODE_TYPE_SLAVE;
+                        stype = "SLAVE";
+                } else {
+                        type = MODE_TYPE_STREAM;
+                        stype = "STREAM";
+                }
+                break;
+        case REG_TRIGGER_EXTERNAL:
+        case REG_TRIGGER_PULSEWIDTH:
+        case REG_TRIGGER_SELF:
+        case REG_TRIGGER_SINGLE:
+                type = MODE_TYPE_TRIGGER;
+                stype = "EXT.TRG";
+                break;
+        }
+
+        if (( 0 < state->former_binning_mode ) && ( 0 == state->binning_mode) ) {
+                reset_binning = true;
+        }
+        else {
+                reset_binning = false;
+        }
+
+        mode = vc_mod_find_mode(cam, num_lanes, format, type, binning);
+        if ( (mode == state->mode) && (!(ctrl->flags & FLAG_RESET_ALWAYS) && (type == MODE_TYPE_STREAM) && !reset_binning)) {
+                vc_dbg(dev, "%s(): Module mode %u need not to be set!\n", __FUNCTION__, mode);
+                *reset = 0;
+                return 0;
+        }
+
+        vc_core_get_fourcc_fmt(state->format_code, fourcc);
+        vc_info(dev, "%s(): Set module mode: %u (lanes: %u, format: %s, type: %s)\n", __FUNCTION__,
+                mode, num_lanes, fourcc, stype);
+
+        ret = vc_mod_reset_module(cam, mode);
+        if (ret) {
+                vc_err(dev, "%s(): Unable to set module mode: %u (lanes: %u, format: %s, type: %s) (error: %d)\n", __func__,
+                        mode, num_lanes, fourcc, stype, ret);
+                return ret;
+        }
+
+        state->mode = mode;
+        *reset = 1;
+
+#ifdef READ_DEFAULT_REG_VALUES
+        vc_sen_read_hmax(&cam->ctrl);
+        vc_sen_read_vmax(&cam->ctrl);
+#endif
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_mod_set_mode);
+
+int vc_mod_is_trigger_enabled(struct vc_cam *cam)
+{
+        return cam->state.trigger_mode != REG_TRIGGER_DISABLE;
+}
+
+int vc_mod_set_trigger_mode(struct vc_cam *cam, int mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char *mode_desc;
+
+        if (mode == 0) {
+                mode_desc = "DISABLED";
+                state->trigger_mode = REG_TRIGGER_DISABLE;
+
+        } else if (mode == 1 && ctrl->flags & FLAG_TRIGGER_EXTERNAL) {
+                mode_desc = "EXTERNAL";
+                state->trigger_mode = REG_TRIGGER_EXTERNAL;
+
+        } else if (mode == 2 && ctrl->flags & FLAG_TRIGGER_PULSEWIDTH) {
+                mode_desc = "PULSEWIDTH";
+                state->trigger_mode = REG_TRIGGER_PULSEWIDTH;
+
+        } else if (mode == 3 && ctrl->flags & (FLAG_TRIGGER_SELF | FLAG_TRIGGER_SELF_V2)) {
+                mode_desc = "SELF";
+                state->trigger_mode = REG_TRIGGER_SELF;
+
+        } else if (mode == 4 && ctrl->flags & FLAG_TRIGGER_SINGLE) {
+                mode_desc = "SINGLE";
+                state->trigger_mode = REG_TRIGGER_SINGLE;
+
+        } else if (mode == 5 && ctrl->flags & (FLAG_TRIGGER_SYNC | FLAG_TRIGGER_SLAVE)) {
+                mode_desc = "SYNC";
+                state->trigger_mode = REG_TRIGGER_SYNC;
+
+        } else if (mode == 6 && ctrl->flags & FLAG_TRIGGER_STREAM_EDGE) {
+                mode_desc = "STREAM_EDGE";
+                state->trigger_mode = REG_TRIGGER_STREAM_EDGE;
+
+        } else if (mode == 7 && ctrl->flags & FLAG_TRIGGER_STREAM_LEVEL) {
+                mode_desc = "STREAM_LEVEL";
+                state->trigger_mode = REG_TRIGGER_STREAM_LEVEL;
+
+        } else {
+                vc_err(dev, "%s(): Trigger mode %d not supported!\n", __FUNCTION__, mode);
+                return -EINVAL;
+        }
+
+        vc_core_update_controls(cam);
+
+        vc_info(dev, "%s(): Set trigger mode: %s\n", __FUNCTION__, mode_desc);
+
+        return 0;
+}
+EXPORT_SYMBOL(vc_mod_set_trigger_mode);
+
+int vc_mod_get_trigger_mode(struct vc_cam *cam)
+{
+        switch (cam->state.trigger_mode)  {
+        case REG_TRIGGER_DISABLE:       return 0;
+        case REG_TRIGGER_EXTERNAL:      return 1;
+        case REG_TRIGGER_PULSEWIDTH:    return 2;
+        case REG_TRIGGER_SELF:          return 3;
+        case REG_TRIGGER_SINGLE:        return 4;
+        case REG_TRIGGER_SYNC:          return 5;
+        case REG_TRIGGER_STREAM_EDGE:   return 6;
+        case REG_TRIGGER_STREAM_LEVEL:  return 7;
+        }
+        return 0;
+}
+EXPORT_SYMBOL(vc_mod_get_trigger_mode);
+
+int vc_mod_set_single_trigger(struct vc_cam *cam)
+{
+        struct i2c_client *client = cam->ctrl.client_mod;
+        struct device *dev = &client->dev;
+
+        vc_info(dev, "%s(): Set single trigger\n", __FUNCTION__);
+
+        return i2c_write_reg(dev, client, MOD_REG_EXTTRIG, REG_TRIGGER_SINGLE, __FUNCTION__);
+}
+EXPORT_SYMBOL(vc_mod_set_single_trigger);
+
+
+int vc_mod_set_io_mode(struct vc_cam *cam, int mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char *mode_desc = NULL;
+
+        if (mode == 0) {
+                mode_desc = "DISABLED";
+                state->io_mode = REG_IO_DISABLE;
+
+        } else if (ctrl->flags & FLAG_IO_ENABLED) {
+                switch (mode) {
+                case 1:
+                        mode_desc = "FLASH ACTIVE HIGH";
+                        state->io_mode = REG_IO_FLASH_ENABLE;
+                        break;
+                case 2:
+                        mode_desc = "FLASH ACTIVE LOW";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_FLASH_ACTIVE_LOW;
+                        break;
+                case 3:
+                        mode_desc = "TRIGGER ACTIVE LOW";
+                        state->io_mode = REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                case 4:
+                        mode_desc = "TRIGGER ACTIVE LOW / FLASH ACTIVE HIGH";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                case 5:
+                        mode_desc = "TRIGGER AND FLASH ACTIVE LOW";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_FLASH_ACTIVE_LOW | REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                }
+                if (ctrl->flags & FLAG_EXPOSURE_OMNIVISION) {
+                        state->io_mode |= REG_IO_XTRIG_ENABLE;
+                }
+        }
+
+        if (mode_desc == NULL) {
+                vc_err(dev, "%s(): IO mode %d not supported!\n", __FUNCTION__, mode);
+                return -EINVAL;
+        }
+
+        vc_info(dev, "%s(): Set IO mode: %s\n", __FUNCTION__, mode_desc);
+
+        return 0;
+}
+EXPORT_SYMBOL(vc_mod_set_io_mode);
+
+int vc_mod_get_io_mode(struct vc_cam *cam)
+{
+        switch (cam->state.io_mode)  {
+        case REG_IO_DISABLE: 		return 0;
+        case REG_IO_FLASH_ENABLE: 	return 1;
+        }
+        return 0;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for the VC MIPI Sensors
+
+int vc_sen_write_mode(struct vc_ctrl *ctrl, int mode)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        __u8 value;
+        int ret = 0;
+
+        vc_dbg(dev, "%s(): Write sensor mode: %s\n", __FUNCTION__, (mode == ctrl->csr.sen.mode_standby)? "standby" : "operating");
+
+        // TODO: Check if it is realy necessary to swap order of write opertations.
+        if(mode == ctrl->csr.sen.mode_standby) {
+                value = ctrl->csr.sen.mode_standby;
+                if(ctrl->csr.sen.mode.l) {
+                        ret = i2c_write_reg(dev, client, ctrl->csr.sen.mode.l, value, __FUNCTION__);
+                }
+                if(ctrl->csr.sen.mode.m) {
+                        ret |= i2c_write_reg(dev, client, ctrl->csr.sen.mode.m, value, __FUNCTION__);
+                }
+        } else {
+                value = ctrl->csr.sen.mode_operating;
+                if(ctrl->csr.sen.mode.m) {
+                        ret |= i2c_write_reg(dev, client, ctrl->csr.sen.mode.m, value, __FUNCTION__);
+                }
+                if(ctrl->csr.sen.mode.l) {
+                        ret = i2c_write_reg(dev, client, ctrl->csr.sen.mode.l, value, __FUNCTION__);
+                }
+        }
+        if (ret)
+                vc_err(dev, "%s(): Couldn't write sensor mode: 0x%02x (error: %d)\n", __FUNCTION__, mode, ret);
+
+        return ret;
+}
+
+static int vc_sen_read_image_size(struct vc_ctrl *ctrl, struct vc_frame *size)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        size->width = i2c_read_reg2(dev, client, &ctrl->csr.sen.o_width, __FUNCTION__);
+        size->height = i2c_read_reg2(dev, client, &ctrl->csr.sen.o_height, __FUNCTION__);
+
+        vc_dbg(dev, "%s(): Read image size (width: %u, height: %u)\n", __FUNCTION__, size->width, size->height);
+
+        return 0;
+}
+
+struct vc_binning *vc_core_get_binning(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        if (state->binning_mode >= ARRAY_SIZE(ctrl->binnings)) {
+                vc_err(dev, "%s(): Invalid binning mode! \n", __FUNCTION__);
+                return NULL;
+        }
+
+        return &ctrl->binnings[state->binning_mode];
+}
+
+void vc_core_calculate_roi(struct vc_cam *cam, __u32 *left, __u32 *right, __u32 *width,
+        __u32 *top, __u32 *bottom, __u32 *height, __u32 *o_width, __u32 *o_height)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        struct vc_binning *binning = vc_core_get_binning(cam);
+        __u32 frame_height = state->frame.height + state->height_offset;
+
+        if (NULL == binning) {
+                vc_err(dev, "%s() Could not get binning struct!\n", __FUNCTION__);
+                return;
+        }
+
+        *left = ctrl->frame.left + state->frame.left;
+        *top = ctrl->frame.top + state->frame.top;
+        if ((binning->h_factor == 0) || (binning->v_factor == 0)) {
+                *width = state->frame.width;
+                *height = frame_height;
+
+        } else {
+                *width = state->frame.width * binning->h_factor;
+                *height = frame_height * binning->v_factor;
+        }
+
+        *o_width = state->frame.width;
+        *o_height = frame_height;
+
+        if (ctrl->flags & FLAG_DOUBLE_HEIGHT) {
+                *top *= 2;
+                *height *= 2;
+                *o_height *= 2;
+        }
+        
+        *right = *left + *width;
+        *bottom = *top + *height;
+}
+
+int vc_sen_write_binning_mode_regs(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = &ctrl->client_sen->dev;
+        struct i2c_client *client = ctrl->client_sen;
+        struct vc_mode mode = vc_core_get_mode(cam);
+        int index = 0;
+        int ret = 0;
+
+        struct vc_reg *regs = mode.binning_mode_regs;
+        while (regs[index].address > 0) {
+                ret |= i2c_write_reg(dev, client, regs[index].address, regs[index].value, __FUNCTION__);
+                index++;
+        }
+
+        return ret;
+}
+
+static int vc_sen_write_hmax(struct vc_ctrl *ctrl, __u32 hmax)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_notice(dev, "%s(): Write sensor HMAX: 0x%08x (%u)\n", __FUNCTION__, hmax, hmax);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.hmax, hmax, __FUNCTION__);
+}
+
+static int vc_sen_set_hmax(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 hmax = vc_core_get_hmax(cam, num_lanes, format, binning);
+
+#ifdef ENABLE_ADVANCED_CONTROL
+        if (cam->state.hmax_overwrite < 0) {
+                return 0;
+        }
+#endif
+        return vc_sen_write_hmax(ctrl, hmax);
+}
+
+int vc_sen_set_roi(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_desc *desc = &cam->desc;
+
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        struct vc_binning *binning = vc_core_get_binning(cam);
+        int w_left, w_top, w_right, w_bottom, w_width, w_height, o_width, o_height;
+        int ret = 0;
+        vc_csr2 vc2OP_BLK_HWIDTH = (vc_csr2) { .l = 0x30d0, .m = 0x30d1 };
+        vc_csr2 vc2INFO_HWIDTH   = (vc_csr2) { .l = 0x30d2, .m = 0x30d3 };
+
+        vc_csr2 DIG_CROP_IMAGE_WIDTH  = (vc_csr2) { .l = 0x040d, .m = 0x040c };
+        vc_csr2 DIG_CROP_IMAGE_HEIGHT = (vc_csr2) { .l = 0x040f, .m = 0x040e };
+
+        if (NULL == binning) {
+                vc_err(dev, "%s() Could not get binning struct!\n", __FUNCTION__);
+                return -EINVAL;
+        }
+
+        vc_dbg(dev, "%s() h_factor: %d, v_factor: %d \n", __FUNCTION__,
+                binning->h_factor, binning->v_factor);
+
+        i2c_write_regs(client, binning->regs, __FUNCTION__);
+
+        vc_core_calculate_roi(cam, &w_left, &w_right, &w_width, &w_top, &w_bottom, &w_height, &o_width, &o_height);
+
+        vc_dbg(dev, "%s(): Set sensor roi: "
+                "(left-width-right: %u+%u=%u=>%u, top-height-bottom: %u+%u=%u=>%u)\n",
+                __FUNCTION__,
+                w_left, w_width, w_right, o_width,
+                w_top, w_height, w_bottom, o_height);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.o_width, o_width, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.o_height, o_height, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.h_start, w_left, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.v_start, w_top, __FUNCTION__);
+
+        if (ctrl->flags & FLAG_PREGIUS_S) {
+                ret |= i2c_write_reg2(dev, client, &vc2OP_BLK_HWIDTH, o_width, __FUNCTION__);
+                ret |= i2c_write_reg2(dev, client, &vc2INFO_HWIDTH, o_width, __FUNCTION__);
+        } else {
+                if (MOD_ID_IMX412 == desc->mod_id) {
+                        ret |= i2c_write_reg2(dev, client, &DIG_CROP_IMAGE_WIDTH, o_width, __FUNCTION__);
+                        ret |= i2c_write_reg2(dev, client, &DIG_CROP_IMAGE_HEIGHT, o_height, __FUNCTION__);
+                } 
+                ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.h_end, w_right, __FUNCTION__);
+                ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.v_end, w_bottom, __FUNCTION__);
+                ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.w_width, w_width, __FUNCTION__);
+                ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.w_height, w_height, __FUNCTION__);
+        }
+        ret |= vc_sen_write_binning_mode_regs(cam);
+        ret |= vc_sen_set_hmax(cam);
+
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set sensor roi: "
+                        "(left-width-right: %u+%u=%u=>%u, top-height-bottom: %u+%u=%u=>%u)\n",
+                        __FUNCTION__,
+                        w_left, w_width, w_right, o_width,
+                        w_top, w_height, w_bottom, o_height);
+                return ret;
+        }
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_sen_set_roi);
+
+static int vc_sen_write_vmax(struct vc_ctrl *ctrl, __u32 vmax)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor VMAX: 0x%08x (%u)\n", __FUNCTION__, vmax, vmax);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.vmax, vmax, __FUNCTION__);
+}
+
+static int vc_sen_write_shs(struct vc_ctrl *ctrl, __u32 shs)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor SHS: 0x%08x (%u)\n", __FUNCTION__, shs, shs);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.shs, shs, __FUNCTION__);
+}
+
+static int vc_sen_write_flash_duration(struct vc_ctrl *ctrl, __u32 duration)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor flash duration: 0x%08x (%u)\n", __FUNCTION__, duration, duration);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.flash_duration, duration, __FUNCTION__);
+}
+
+static int vc_sen_write_flash_offset(struct vc_ctrl *ctrl, __u32 offset)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor flash offset: 0x%08x (%u)\n", __FUNCTION__, offset, offset);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.flash_offset, offset, __FUNCTION__);
+}
+
+static int vc_core_mdB_to_times(int mdB)
+{
+        // times = 10^(mdB/10000) = 1.000230285^mdB
+        __u64 base = 100023028; 
+        __u64 times = base;
+        int index = 0;
+        for (index = 1; index <= mdB; index++) {
+                times = (times * base) / 100000000;
+        }
+        return times / 100000;
+}
+
+int vc_sen_set_gain(struct vc_cam *cam, int gain_mdB)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        int gain_times = 0;
+        int gain_fraction = 0;
+        int gain = 0;
+        int ret = 0;
+
+        if (gain_mdB < 0) {
+                gain_mdB = 0;
+        }
+        if (gain_mdB > ctrl->gain.max_mdB) {
+                gain_mdB = ctrl->gain.max_mdB;
+        }
+
+        switch (ctrl->gain.type) {
+        case GAIN_LINEAR:
+                gain = ((1000000 * (__u64)ctrl->gain.max) / ctrl->gain.max_mdB) 
+                        * gain_mdB / 1000000;
+                break;
+
+        case GAIN_LOGARITHMIC:
+                gain_times = 1000000/vc_core_mdB_to_times(gain_mdB/2);
+                vc_dbg (dev, "%s(): GAIN_LOG %u mdB -> %u times\n", __FUNCTION__, gain_mdB, gain_times);
+                gain = (1000 * ctrl->gain.c1 - gain_times * ctrl->gain.c0) / 1000;
+                break;
+
+        case GAIN_RECIPROCAL:
+                gain_times = vc_core_mdB_to_times(gain_mdB);
+                vc_dbg(dev, "%s(): GAIN_REC %u mdB -> %u times\n", __FUNCTION__, gain_mdB, gain_times);
+                gain = ctrl->gain.c1 - 1000 * (__u64)ctrl->gain.c0 / gain_times;
+                break;
+
+        case GAIN_FRACTIONAL:
+                gain_times = vc_core_mdB_to_times(gain_mdB);
+                gain_fraction = (( gain_times - (gain_times / 1000) * 1000) * 16 ) / 1000;
+                gain = (gain_times / 1000 << 4) + gain_fraction;
+                vc_dbg(dev, "%s(): GAIN_FRA %u mdB -> %u times (%u.%u) => 0x%02x\n", __FUNCTION__, gain_mdB, gain_times,
+                        gain_times / 1000, gain_fraction, gain );
+                break;
+        }
+
+        if (gain > ctrl->gain.max) {
+                gain = ctrl->gain.max;
+        }
+
+        vc_info(dev, "%s(): Set sensor gain: %u mdB (%u/%u) (exposure: %u us)\n", __FUNCTION__, 
+                gain_mdB, gain, ctrl->gain.max, cam->state.exposure);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.gain, gain, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set gain (error: %d)\n", __FUNCTION__, ret);
+                return ret;
+        }
+
+        cam->state.gain = gain_mdB;
+        return 0;
+}
+EXPORT_SYMBOL(vc_sen_set_gain);
+
+int vc_sen_set_blacklevel(struct vc_cam *cam, __u32 blacklevel_rel)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        int ret = 0;
+        __u8 num_lanes = vc_core_get_num_lanes(cam);
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+
+        __u8 binning = state->binning_mode;
+        __u32 blacklevel_max = vc_core_get_blacklevel(cam, num_lanes, format, binning).max;
+        __u32 blacklevel_abs = (__u32)DIV_ROUND_CLOSEST((blacklevel_rel * blacklevel_max), 100000);
+
+        vc_info(dev, "%s(): Set sensor black level: %u (%u/%u)\n", __FUNCTION__, 
+                blacklevel_rel, blacklevel_abs, blacklevel_max);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.blacklevel, blacklevel_abs, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set black level (error: %d)\n", __FUNCTION__, ret);
+                return ret;
+        }
+
+        state->blacklevel = blacklevel_rel;
+        return 0;
+}
+EXPORT_SYMBOL(vc_sen_set_blacklevel);
+
+int vc_sen_start_stream(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &ctrl->client_sen->dev;
+        int ret = 0;
+
+        vc_info(dev, "%s(): Start streaming\n", __FUNCTION__);
+        vc_dbg(dev, "%s(): MM: 0x%02x, TM: 0x%02x, IO: 0x%02x\n",
+                __FUNCTION__, state->mode, state->trigger_mode, state->io_mode);
+
+        if (state->streaming) {
+                vc_sen_stop_stream(cam);
+        }
+
+        if ((ctrl->flags & FLAG_EXPOSURE_SONY || ctrl->flags & FLAG_EXPOSURE_NORMAL) || 
+            (ctrl->flags & FLAG_EXPOSURE_OMNIVISION && !vc_mod_is_trigger_enabled(cam))) {
+                ret |= vc_sen_write_mode(ctrl, ctrl->csr.sen.mode_operating);
+                if (ret)
+                        vc_err(dev, "%s(): Unable to start streaming (error: %d)\n", __FUNCTION__, ret);
+        }
+
+        if (ctrl->flags & FLAG_TRIGGER_SLAVE && state->trigger_mode == REG_TRIGGER_SYNC) {
+                ret |= vc_mod_write_io_mode(client_mod, REG_IO_XTRIG_ENABLE);
+                ret |= vc_mod_write_trigger_mode(client_mod, REG_TRIGGER_DISABLE);
+
+        } else {
+                ret |= vc_mod_write_io_mode(client_mod, state->io_mode);
+                ret |= vc_mod_write_trigger_mode(client_mod, state->trigger_mode);
+        }
+        state->streaming = 1;
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_sen_start_stream);
+
+int vc_sen_stop_stream(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &ctrl->client_sen->dev;
+        int ret = 0;
+
+        vc_info(dev, "%s(): Stop streaming\n", __FUNCTION__);
+
+        ret |= vc_mod_write_trigger_mode(client_mod, REG_TRIGGER_DISABLE);
+        ret |= vc_mod_write_io_mode(client_mod, REG_IO_DISABLE);
+
+        ret |= vc_sen_write_mode(ctrl, ctrl->csr.sen.mode_standby);
+        if (ret)
+                vc_err(dev, "%s(): Unable to stop streaming (error: %d)\n", __FUNCTION__, ret);
+
+        state->streaming = 0;
+
+        vc_dbg(dev, "%s(): ----------------------------------------------------------\n", __FUNCTION__);
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_sen_stop_stream);
+
+// ------------------------------------------------------------------------------------------------
+
+static __u32 vc_core_calculate_period_1H(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 binning)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        int binning_index = 0;
+        __u8 index = 0;
+
+        // TODO: bad code style -> refactoring
+        binning_index = (ctrl->flags & FLAG_USE_BINNING_INDEX) ? binning : 0;
+
+        for (index = 0; index <= MAX_VC_MODES; index++) {
+                struct vc_mode *mode = &ctrl->mode[index];
+                if (mode->num_lanes == num_lanes && mode->format == format && (binning_index == ctrl->mode[index].binning)) {
+                        return ((__u64)mode->hmax * 1000000000) / ctrl->clk_pixel;
+                }
+        }
+
+        return 0;
+}
+
+__u32 vc_core_get_time_per_line_ns(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        return vc_core_calculate_period_1H(cam, state->num_lanes, format, state->binning_mode);
+}
+EXPORT_SYMBOL(vc_core_get_time_per_line_ns);
+
+int vc_core_set_binning_mode(struct vc_cam *cam, int mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_info(dev, "%s(): Set binning mode: %u\n", __FUNCTION__, mode);
+
+        if (mode > ctrl->max_binning_modes_used) {
+                vc_err(dev, "%s(): Couldn't set binning mode (max supported modes: %d)\n", __FUNCTION__, ctrl->max_binning_modes_used);
+                return -1;
+        }
+
+        state->binning_mode = mode;
+        vc_core_update_controls(cam);
+
+        return 0;
+}
+EXPORT_SYMBOL(vc_core_set_binning_mode);
+
+static void vc_core_calculate_vmax(struct vc_cam *cam, __u32 period_1H_ns)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u64 frametime_ns;
+        __u64 frametime_1H;
+
+        state->vmax = vc_core_get_optimized_vmax(cam);
+        // Lower the frame rate if the frame rate setting requires it.
+        if (state->framerate > 0) {
+                frametime_ns = 1000000000000 / state->framerate;
+                frametime_1H = frametime_ns / period_1H_ns;
+                if (frametime_1H > state->vmax) {
+                        state->vmax = frametime_1H;
+                }
+
+                vc_dbg(dev, "%s(): framerate: %u mHz, frametime: %llu ns, %llu 1H\n", __FUNCTION__,
+                        state->framerate, frametime_ns, frametime_1H);
+        }
+}
+
+static void vc_calculate_exposure_sony(struct vc_cam *cam, __u64 exposure_1H)
+{
+        struct vc_state *state = &cam->state;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 shs_min = vc_core_get_vmax(cam, num_lanes, format, binning).min;
+
+        // Exposure time [s] = (1 H period) × (Number of lines per frame - SHS)
+        //                     + Exposure time error (t OFFSET ) [µs]
+
+        // Is exposure time less than frame time?
+        if (exposure_1H < state->vmax - shs_min) {
+                // Yes then calculate exposure delay (shs) in between frame time.
+                // |                 VMAX (frame time)             ---> |
+                // | SHS_MIN |                                          |
+                // +----------------------------+-----------------------+
+                // | SHS (exposure delay) --->  |    exposure time ---> |
+                state->shs = state->vmax - exposure_1H;
+
+        } else {
+                // No, then increase frame time and set exposure delay to the minimal value.
+                // |                 VMAX (frame time)                   ---> |
+                // +---------+------------------------------------------------+
+                // | SHS     |                             exposure time ---> |
+                state->vmax = shs_min + exposure_1H;
+                state->shs = shs_min;
+        }
+
+        // Special case: Framerate of slave module has to be a little bit faster (Tested with IMX183)
+        if (state->trigger_mode == REG_TRIGGER_SYNC) {
+                state->vmax--;
+        }
+}
+
+static void vc_calculate_exposure_normal(struct vc_cam *cam, __u64 exposure_1H)
+{
+        struct vc_state *state = &cam->state;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 shs_min = vc_core_get_vmax(cam, num_lanes, format, binning).min;
+
+        // Is exposure time greater than shs_min and less than frame time?
+        if (shs_min <= exposure_1H && exposure_1H < state->vmax) {
+                // Yes then calculate exposure delay (shs) in between frame time.
+                // |                 VMAX (frame time)             ---> |
+                // +------------------------+---------------------------+
+                // | exposure time ---> SHS |                           |
+                state->shs = exposure_1H;
+
+        } else if (exposure_1H < shs_min) {
+                // Yes, then set shs equal to shs_min
+                // |                 VMAX (frame time)             ---> |
+                // +----------------------------+-----------------------+
+                // | SHS_MIN |                                          |
+                state->shs = shs_min;
+
+        } else {
+                // |                 VMAX (frame time)                   ---> |
+                // +----------------------------------------------------------+
+                // |                                       exposure time ---> |
+                state->vmax = exposure_1H;
+                state->shs = exposure_1H;
+        }
+}
+
+static void vc_calculate_exposure(struct vc_cam *cam, __u32 exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 period_1H_ns = 0;
+        __u64 exposure_ns;
+        __u64 exposure_1H;
+        
+        __u32 vmax_def = vc_core_get_vmax(cam, num_lanes, format, binning).def;
+        __u32 vmax_min = vc_core_get_vmax(cam, num_lanes, format, binning).min;
+
+        period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format, binning);
+        vc_core_calculate_vmax(cam, period_1H_ns);
+
+        // Convert exposure time from µs to ns.
+        exposure_ns = (__u64)(exposure_us)*1000;
+        // Calculate number of lines equivalent to the exposure time without shs_min.
+        exposure_1H = exposure_ns / period_1H_ns;
+
+        if (ctrl->flags & FLAG_EXPOSURE_SONY) {
+                vc_calculate_exposure_sony(cam, exposure_1H);
+
+        } else if (ctrl->flags & FLAG_EXPOSURE_NORMAL || ctrl->flags & FLAG_EXPOSURE_OMNIVISION) {
+                vc_calculate_exposure_normal(cam, exposure_1H);
+        }
+
+        vc_dbg(dev, "%s(): flags: 0x%04x, period_1H_ns: %u, shs: %u/%u, vmax: %u/%u\n", __FUNCTION__,
+                ctrl->flags, period_1H_ns, state->shs, vmax_min, state->vmax, vmax_def);
+}
+
+static void vc_calculate_trig_exposure(struct vc_cam *cam, __u32 exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_mbus_code_to_format(state->format_code);
+        __u8 binning = state->binning_mode;
+        __u32 min_frametime_us = 0;
+        __u32 frametime_us = 0;
+        __u32 retrigger_min = vc_core_get_retrigger(cam, num_lanes, format, binning);
+
+        // NOTE: Currently it is not possible to use an optimized minimal frame time.
+        // min_frametime_us = 1000000000 / vc_core_calculate_max_frame_rate(cam, num_lanes, format) + 1000;
+        min_frametime_us = ((__u64)retrigger_min * 1000000) / ctrl->clk_ext_trigger;
+        frametime_us = min_frametime_us;
+
+        if (state->trigger_mode & REG_TRIGGER_SELF) {
+                if (state->framerate > 0) {
+                        frametime_us = 1000000000 / state->framerate;
+                }
+                if (frametime_us < min_frametime_us) {
+                        frametime_us = min_frametime_us;
+                }
+                if (ctrl->flags & FLAG_TRIGGER_SELF) {
+                        // NOTE: Currently it is not possible to adjust the frame time 
+                        //       in respect to the exposure time.
+                        // if (exposure_us > (frametime_us - min_frametime_us)) {
+                        // 	frametime_us = exposure_us + min_frametime_us;
+                        // }
+
+                } else if(ctrl->flags & FLAG_TRIGGER_SELF_V2) {
+                        if (frametime_us >= exposure_us) {
+                                frametime_us -= exposure_us;
+                        } else {
+                                frametime_us = 1;
+                        }
+                }
+        }
+
+        vc_dbg(dev, "%s(): min_frametime: %u us, frametime: %u us, exposure: %u us\n", __FUNCTION__,
+                min_frametime_us, frametime_us, exposure_us);
+        state->retrigger_cnt = ((__u64)frametime_us * ctrl->clk_ext_trigger) / 1000000;
+        // NOTE: Check this for different cameras.
+        // if (state->retrigger_cnt < 3240) {
+        // 	state->retrigger_cnt = 3240;
+        // }
+        state->exposure_cnt = ((__u64)exposure_us * ctrl->clk_ext_trigger) / 1000000;
+}
+
+int vc_sen_set_exposure(struct vc_cam *cam, int exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        struct i2c_client *client_mod = ctrl->client_mod;
+        int ret = 0;
+
+        vc_info(dev, "%s(): Set sensor exposure: %u us\n", __FUNCTION__, exposure_us);
+
+        if (exposure_us < ctrl->exposure.min)
+                exposure_us = ctrl->exposure.min;
+        if (exposure_us > ctrl->exposure.max)
+                exposure_us = ctrl->exposure.max;
+
+        state->vmax = 0;
+
+        state->shs = 0;
+        state->exposure_cnt = 0;
+        state->retrigger_cnt = 0;
+
+        if (ctrl->flags & FLAG_EXPOSURE_SONY || ctrl->flags & FLAG_EXPOSURE_NORMAL) {
+                switch (state->trigger_mode) {
+                case REG_TRIGGER_EXTERNAL:
+                case REG_TRIGGER_SINGLE:
+                case REG_TRIGGER_SELF:	
+                        vc_calculate_trig_exposure(cam, exposure_us);
+                        ret |= vc_mod_write_exposure(client_mod, state->exposure_cnt);
+                        // NOTE for FLAG_TRIGGER_SELF
+                        // - Changing retrigger from bigger to smaller values leads to a hang up of the camera. 
+                        // - Changing exposure isn't applied sometimes
+                        if (!state->streaming || ctrl->flags & FLAG_TRIGGER_SELF_V2) {
+                                ret |= vc_mod_write_retrigger(client_mod, state->retrigger_cnt);
+                        }
+                        break;
+                case REG_TRIGGER_PULSEWIDTH:
+                        break;
+                case REG_TRIGGER_DISABLE:
+                case REG_TRIGGER_SYNC:
+                case REG_TRIGGER_STREAM_EDGE:
+                case REG_TRIGGER_STREAM_LEVEL:
+                        vc_calculate_exposure(cam, exposure_us);
+                        ret |= vc_sen_write_shs(ctrl, state->shs);
+                        ret |= vc_sen_write_vmax(ctrl, state->vmax);
+                }
+        
+        } else if (ctrl->flags & FLAG_EXPOSURE_OMNIVISION) {
+                __u32 duration = (((__u64)exposure_us)*ctrl->flash_factor)/1000000;
+
+                vc_calculate_exposure(cam, exposure_us);
+                ret |= vc_sen_write_shs(ctrl, state->shs);
+                ret |= vc_sen_write_vmax(ctrl, state->vmax);
+                ret |= vc_sen_write_flash_duration(ctrl, duration);
+                ret |= vc_sen_write_flash_offset(ctrl, ctrl->flash_toffset);
+        }
+
+        if (ret == 0) {
+                cam->state.exposure = exposure_us;
+        }
+
+        vc_dbg(dev, "%s(): (VMAX: %5u, SHS: %5u), (RETC: %6u, EXPC: %6u)\n",
+                __FUNCTION__, state->vmax, state->shs, state->retrigger_cnt, state->exposure_cnt);
+
+        return ret;
+}
+EXPORT_SYMBOL(vc_sen_set_exposure);
+
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
new file mode 100755
index 0000000..0580757
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_core.h
@@ -0,0 +1,306 @@
+#ifndef _VC_MIPI_CORE_H
+#define _VC_MIPI_CORE_H
+
+// #define DEBUG
+#define ENABLE_ADVANCED_CONTROL
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/videodev2.h>
+
+#define vc_dbg(dev, fmt, ...) dev_dbg(dev, fmt, ##__VA_ARGS__)
+#define vc_info(dev, fmt, ...) dev_info(dev, fmt, ##__VA_ARGS__)
+#define vc_notice(dev, fmt, ...) dev_notice(dev, fmt, ##__VA_ARGS__)
+#define vc_warn(dev, fmt, ...) dev_warn(dev, fmt, ##__VA_ARGS__)
+#define vc_err(dev, fmt, ...) dev_err(dev, fmt, ##__VA_ARGS__)
+
+#define FLAG_RESET_ALWAYS               (1 <<  0)
+#define FLAG_EXPOSURE_SONY              (1 <<  1)
+#define FLAG_EXPOSURE_NORMAL            (1 <<  2)
+#define FLAG_EXPOSURE_OMNIVISION        (1 <<  3)
+
+#define FLAG_IO_ENABLED                 (1 <<  4)
+#define FLAG_FORMAT_GBRG                (1 <<  5)
+#define FLAG_DOUBLE_HEIGHT              (1 <<  6)
+#define FLAG_INCREASE_FRAME_RATE        (1 <<  7)
+
+#define FLAG_TRIGGER_DISABLE            (1 <<  8)
+#define FLAG_TRIGGER_EXTERNAL           (1 <<  9)
+#define FLAG_TRIGGER_PULSEWIDTH         (1 << 10)
+#define FLAG_TRIGGER_SELF               (1 << 11)
+#define FLAG_TRIGGER_SELF_V2            (1 << 12)
+#define FLAG_TRIGGER_SINGLE             (1 << 13)
+#define FLAG_TRIGGER_SYNC               (1 << 14)
+#define FLAG_TRIGGER_STREAM_EDGE        (1 << 15)
+#define FLAG_TRIGGER_STREAM_LEVEL       (1 << 16)
+#define FLAG_TRIGGER_SLAVE              (1 << 17)
+
+#define FLAG_PREGIUS_S                  (1 << 18)
+#define FLAG_USE_BINNING_INDEX          (1 << 19)
+
+#define GAIN_DISABLED                   0
+#define GAIN_LINEAR                     1
+#define GAIN_LOGARITHMIC                2
+#define GAIN_RECIPROCAL                 3
+#define GAIN_FRACTIONAL                 4
+
+#define FORMAT_RAW08                    0x2a
+#define FORMAT_RAW10                    0x2b
+#define FORMAT_RAW12                    0x2c
+#define FORMAT_RAW14                    0x2d
+
+#define MAX_VC_MODES                    16
+#define MAX_BINNING_MODE_REGS           16
+
+
+struct vc_desc_mode {
+        __u8 data_rate[4];
+        __u8 num_lanes;
+        __u8 format;
+        __u8 type;
+        __u8 binning;
+        __u8 reserved2[8];
+};
+
+struct vc_desc {
+        // Module description
+        __u8 magic[12];
+        __u8 manuf[32];
+        __u16 manuf_id;
+        __u8 sen_manuf[8];
+        __u8 sen_type[16];
+        __u16 mod_id;
+        __u16 mod_rev;
+        __u16 chip_id_high;
+        __u16 chip_id_low;
+        __u16 chip_rev;
+        // Sensor registers
+        __u16 csr_mode;
+        __u16 csr_h_start_h;
+        __u16 csr_h_start_l;
+        __u16 csr_v_start_h;
+        __u16 csr_v_start_l;
+        __u16 csr_h_end_h;
+        __u16 csr_h_end_l;
+        __u16 csr_v_end_h;
+        __u16 csr_v_end_l;
+        __u16 csr_o_width_h;
+        __u16 csr_o_width_l;
+        __u16 csr_o_height_h;
+        __u16 csr_o_height_l;
+        __u16 csr_exposure_h;
+        __u16 csr_exposure_m;
+        __u16 csr_exposure_l;
+        __u16 csr_gain_h;
+        __u16 csr_gain_l;
+        // Exposure Settings
+        __u32 clk_ext_trigger;
+        __u32 clk_pixel;
+        __u16 shutter_offset;
+        // Reserved
+        __u8 reserved[4];
+        // Modes
+        __u16 num_modes;
+        __u16 bytes_per_mode;
+        struct vc_desc_mode modes[24];
+        __u32 mbus_codes[5];
+};
+
+typedef struct vc_control {
+        __u32 min;
+        __u32 max;
+        __u32 def;
+} vc_control;
+
+typedef struct vc_gain {
+        __u32 max;
+        __u32 max_mdB;
+        __u32 type;
+        __u32 c0;
+        __u32 c1;
+} vc_gain;
+
+typedef struct vc_frame {
+        __u32 left;
+        __u32 top;
+        __u32 width;
+        __u32 height;
+} vc_frame;
+
+typedef struct vc_csr2 {
+        __u32 l;
+        __u32 m;
+} vc_csr2;
+
+typedef struct vc_csr4 {
+        __u32 l;
+        __u32 m;
+        __u32 h;
+        __u32 u;
+} vc_csr4;
+
+struct vc_sen_csr {
+        struct vc_csr2 mode;
+        __u8 mode_standby;
+        __u8 mode_operating;
+        struct vc_csr4 vmax;
+        struct vc_csr4 hmax;
+        struct vc_csr4 shs;
+        struct vc_csr2 gain;
+        struct vc_csr2 blacklevel;
+        struct vc_csr2 h_start;
+        struct vc_csr2 v_start;
+        struct vc_csr2 h_end;
+        struct vc_csr2 v_end;
+        struct vc_csr2 w_width;
+        struct vc_csr2 w_height;
+        struct vc_csr2 o_width;
+        struct vc_csr2 o_height;
+        struct vc_csr4 flash_duration;
+        struct vc_csr4 flash_offset;
+};
+
+struct vc_csr {
+        struct vc_sen_csr sen;
+};
+
+typedef struct vc_reg {
+        __u16 address;
+        __u8 value;
+} vc_reg;
+
+typedef struct vc_mode {
+        __u8       num_lanes;
+        __u8       format;
+        __u8       binning;
+        __u32      hmax;
+        vc_control vmax;
+        vc_control blacklevel;
+        __u32      retrigger_min;
+        struct vc_reg binning_mode_regs[MAX_BINNING_MODE_REGS];
+} vc_mode;
+
+typedef struct vc_binning {
+        __u8 h_factor;
+        __u8 v_factor;
+        struct vc_reg regs[8];
+} vc_binning;
+
+#define BINNING_START(binning, h, v) \
+        binning = (vc_binning) { .h_factor = h, .v_factor = v }; \
+        { const struct vc_reg regs [] = {
+#define BINNING_END(binning) \
+        , {0, 0} }; memcpy(&binning.regs, regs, sizeof(regs)); }
+
+typedef struct dt_binning_mode {
+        __u32 binning_mode;
+        bool  mode_set;
+} dt_binning_mode;
+
+struct vc_ctrl {
+        // Communication
+        int mod_i2c_addr;
+        struct i2c_client *client_sen;
+        struct i2c_client *client_mod;
+        // Controls
+        struct vc_mode mode[MAX_VC_MODES];
+        struct vc_control exposure;
+        struct vc_gain gain;
+        struct vc_control framerate;
+        // Modes & Frame Formats
+        struct vc_frame frame;          // Pixel
+        struct vc_binning binnings[8];
+        __u8 max_binning_modes_used;
+        
+        // Control and status registers
+        struct vc_csr csr;
+        // Exposure
+        __u32 clk_ext_trigger;          // Hz
+        __u32 clk_pixel;                // Hz
+        // Flash
+        __u32 flash_factor;
+        __s32 flash_toffset;
+        // Special features
+        __u32 flags;
+};
+
+struct vc_state {
+        __u8 mode;
+        __u32 vmax;
+        __u32 shs;
+        __u32 exposure;                 // µs
+        __u32 gain;                     // mdB
+        __u32 blacklevel;
+        __u32 exposure_cnt;
+        __u32 retrigger_cnt;
+        __u32 framerate;
+        __u32 format_code;
+        struct vc_frame frame;          // Pixel
+        __u8 num_lanes;
+        __u8 io_mode;
+        __u8 trigger_mode;
+        __u8 binning_mode;
+        __u8 former_binning_mode;
+        int power_on;
+        int streaming;
+        __u8 flags;
+#ifdef ENABLE_ADVANCED_CONTROL
+        __s32 hmax_overwrite;
+        __s32 vmax_overwrite;
+        __s32 height_offset;
+#endif
+};
+
+struct vc_cam {
+        struct vc_desc desc;
+        struct vc_ctrl ctrl;
+        struct vc_state state;
+};
+
+// --- Helper functions to allow i2c communication for customization ----------
+int vc_read_i2c_reg(struct i2c_client *client, const __u16 addr);
+int vc_write_i2c_reg(struct i2c_client *client, const __u16 addr, const __u8 value);
+struct i2c_client *vc_mod_get_client(struct device *dev, struct i2c_adapter *adapter, __u8 i2c_addr);
+
+// --- Helper functions for internal data structures --------------------------
+void vc_core_print_debug(struct vc_cam *cam); // Only used by NVIDIA driver
+struct device *vc_core_get_sen_device(struct vc_cam *cam);
+vc_mode vc_core_get_mode(struct vc_cam *cam);
+int vc_core_enum_mbus_code(struct vc_cam *cam, __u32 index);
+int vc_core_set_format(struct vc_cam *cam, __u32 code);
+__u32 vc_core_get_format(struct vc_cam *cam);
+int vc_core_set_frame(struct vc_cam *cam, __u32 left, __u32 top, __u32 width, __u32 height);
+struct vc_frame *vc_core_get_frame(struct vc_cam *cam);
+int vc_core_set_num_lanes(struct vc_cam *cam, __u32 number);
+__u32 vc_core_get_num_lanes(struct vc_cam *cam);
+int vc_core_set_framerate(struct vc_cam *cam, __u32 framerate);
+__u32 vc_core_get_framerate(struct vc_cam *cam);
+__u32 vc_core_get_time_per_line_ns(struct vc_cam *cam); // Only used by NXP driver
+int vc_core_set_binning_mode(struct vc_cam *cam, int mode);
+#ifdef ENABLE_ADVANCED_CONTROL
+int vc_core_set_hmax_overwrite(struct vc_cam *cam, __s32 hmax_overwrite); // Only used by NXP driver
+int vc_core_set_vmax_overwrite(struct vc_cam *cam, __s32 vmax_overwrite); // Only used by NXP driver
+int vc_core_set_height_offset(struct vc_cam *cam, __s32 vmax_overwrite); // Only used by NXP driver
+#endif
+
+// --- Function to initialize the vc core --------------------------------------
+int vc_core_init(struct vc_cam *cam, struct i2c_client *client);
+int vc_core_release(struct vc_cam *cam);
+int vc_core_update_controls(struct vc_cam *cam); // Only used by NVIDIA driver
+
+// --- Functions for the VC MIPI Controller Module ----------------------------
+int vc_mod_set_mode(struct vc_cam *cam, int *reset);
+int vc_mod_set_trigger_mode(struct vc_cam *cam, int mode);
+int vc_mod_get_trigger_mode(struct vc_cam *cam); // Only used by NVIDIA driver
+int vc_mod_set_single_trigger(struct vc_cam *cam);
+int vc_mod_set_io_mode(struct vc_cam *cam, int mode);
+
+// --- Functions for the VC MIPI Sensors --------------------------------------
+int vc_sen_set_roi(struct vc_cam *cam);
+int vc_sen_set_exposure(struct vc_cam *cam, int exposure);
+int vc_sen_set_gain(struct vc_cam *cam, int gain);
+int vc_sen_set_blacklevel(struct vc_cam *cam, __u32 blacklevel);
+int vc_sen_start_stream(struct vc_cam *cam);
+int vc_sen_stop_stream(struct vc_cam *cam);
+
+#endif // _VC_MIPI_CORE_H
\ No newline at end of file
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
new file mode 100644
index 0000000..a5cce2e
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.c
@@ -0,0 +1,1036 @@
+#include "vc_mipi_modules.h"
+#include <linux/v4l2-mediabus.h>
+
+
+#define INIT_MESSAGE(camera) \
+        struct device *dev = &ctrl->client_mod->dev; \
+        vc_notice(dev, "%s(): Initialising module control for %s\n", __FUNCTION__, camera);
+
+#define GAIN_LIN(_max, _max_mdB) \
+        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+        .type = GAIN_LINEAR};
+
+#define GAIN_LOG(_max, _max_mdB, _c0, _c1) \
+        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+        .type = GAIN_LOGARITHMIC, .c0 = _c0, .c1 = _c1 };
+
+#define GAIN_REC(_max, _max_mdB, _c0, _c1) \
+        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+        .type = GAIN_RECIPROCAL, .c0 = _c0, .c1 = _c1 };
+
+#define GAIN_FRA(_max, _max_mdB) \
+        ctrl->gain = (vc_gain) { .max = _max, .max_mdB = _max_mdB, \
+        .type = GAIN_FRACTIONAL};
+
+#define FRAME(_left, _top, _width, _height) \
+        ctrl->frame = (vc_frame) { .left = _left, .top = _top, .width = _width, .height = _height };
+
+#define MODE(index, lanes, format, binning, _hmax, vmax_min, vmax_max, vmax_def, \
+        blacklevel_max, blacklevel_def, _retrigger_min) \
+        ctrl->mode[index] = (vc_mode) { lanes, format, binning, \
+                .hmax = _hmax,  \
+                .vmax = {.min = vmax_min, .max = vmax_max, .def = vmax_def}, \
+                .blacklevel = {.min = 0, .max = blacklevel_max,  .def = blacklevel_def }, \
+                .retrigger_min = _retrigger_min };
+
+#define BINNING_MODE_REGS(_mode, ...) \
+        if (MAX_VC_MODES > _mode) { \
+                do { \
+                        const struct vc_reg _binning_mode_regs [] = { __VA_ARGS__ }; \
+                        int vrs = 0; \
+                        vrs = sizeof(_binning_mode_regs) / sizeof(vc_reg); \
+                                if (MAX_BINNING_MODE_REGS > vrs) { \
+                                        memcpy(&ctrl->mode[_mode].binning_mode_regs, _binning_mode_regs, sizeof(_binning_mode_regs)); \
+                                } \
+                } while (0); \
+        }
+
+int vc_mod_is_color_sensor(struct vc_desc *desc)
+{
+        if (desc->sen_type) {
+                __u32 len = strnlen(desc->sen_type, 16);
+                if (len > 0 && len < 17) {
+                        return *(desc->sen_type + len - 1) == 'C';
+                }
+        }
+        return 0;
+}
+
+static void vc_init_ctrl(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->exposure                  = (vc_control) { .min =   1, .max = 100000000, .def =  10000 };
+        ctrl->framerate                 = (vc_control) { .min =   0, .max =   1000000, .def =      0 };
+
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = desc->csr_mode, .m = 0x0000 };
+
+        ctrl->csr.sen.mode_standby      = 0x00; 
+        ctrl->csr.sen.mode_operating    = 0x01;
+        
+        ctrl->csr.sen.shs.l             = desc->csr_exposure_l;
+        ctrl->csr.sen.shs.m             = desc->csr_exposure_m;
+        ctrl->csr.sen.shs.h             = desc->csr_exposure_h;
+        ctrl->csr.sen.shs.u             = 0;
+        
+        ctrl->csr.sen.gain.l            = desc->csr_gain_l;
+        ctrl->csr.sen.gain.m            = desc->csr_gain_h;
+
+        ctrl->csr.sen.h_start.l         = desc->csr_h_start_l;
+        ctrl->csr.sen.h_start.m         = desc->csr_h_start_h;
+        ctrl->csr.sen.v_start.l         = desc->csr_v_start_l;
+        ctrl->csr.sen.v_start.m         = desc->csr_v_start_h;
+        ctrl->csr.sen.h_end.l           = desc->csr_h_end_l;
+        ctrl->csr.sen.h_end.m           = desc->csr_h_end_h;
+        ctrl->csr.sen.v_end.l           = desc->csr_v_end_l;
+        ctrl->csr.sen.v_end.m           = desc->csr_v_end_h;
+        ctrl->csr.sen.o_width.l         = desc->csr_o_width_l;
+        ctrl->csr.sen.o_width.m         = desc->csr_o_width_h;
+        ctrl->csr.sen.o_height.l        = desc->csr_o_height_l;
+        ctrl->csr.sen.o_height.m        = desc->csr_o_height_h;
+
+        ctrl->frame.left                = 0;
+        ctrl->frame.top                 = 0;
+
+        ctrl->clk_ext_trigger           = desc->clk_ext_trigger;
+        ctrl->clk_pixel                 = desc->clk_pixel;
+}
+
+static void vc_init_ctrl_imx183_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x7004, .m = 0x7005, .h = 0x7006, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x7002, .m = 0x7003, .h = 0x0000, .u = 0x0000 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_SELF |
+                                          FLAG_TRIGGER_SINGLE | FLAG_TRIGGER_SYNC;
+}
+
+static void vc_init_ctrl_imx252_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0210, .m = 0x0211, .h = 0x0212, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x0214, .m = 0x0215, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0454, .m = 0x0455 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+static void vc_init_ctrl_imx290_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        GAIN_LIN(240, 72000)
+        
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3018, .m = 0x3019, .h = 0x301A, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x300a, .m = 0x300b };
+
+        FRAME(0, 0, 1920, 1080)
+        
+        ctrl->clk_ext_trigger           = 74250000;
+        ctrl->clk_pixel                 = 74250000;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+}
+
+static void vc_init_ctrl_imx296_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        GAIN_LIN(480, 48000)
+        
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3010, .m = 0x3011, .h = 0x3012, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x300A };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating	= 0x00;
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3254, .m = 0x3255 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH | FLAG_TRIGGER_SELF_V2;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX178/IMX178C  (Rev.02)
+//  6.44 MegaPixel Starvis
+
+static void vc_init_ctrl_imx178(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX178")
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3015, .m = 0x3016 };
+
+        FRAME(0, 0, 3072, 2048)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     680,    9,  0x1ffff,  2126,  255,   50,   2698560)
+        MODE( 1, 2, FORMAT_RAW10, 0,     840,    9,  0x1ffff,  2126, 1023,   50,   2698560)
+        MODE( 2, 2, FORMAT_RAW12, 0,     984,    9,  0x1ffff,  2126, 1023,  200,   2698560)
+        MODE( 3, 2, FORMAT_RAW14, 0,    1156,    9,  0x1ffff,  2126, 4095,  800,   2698560)
+        MODE( 4, 4, FORMAT_RAW08, 0,     600,    9,  0x1ffff,  2126,  255,   50,   2698560)
+        MODE( 5, 4, FORMAT_RAW10, 0,     600,    9,  0x1ffff,  2126, 1023,   50,   2698560)
+        MODE( 6, 4, FORMAT_RAW12, 0,     680,    9,  0x1ffff,  2126, 1023,  200,   2698560)
+        MODE( 7, 4, FORMAT_RAW14, 0,    1156,    9,  0x1ffff,  2126, 4095,  800,   2698560)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX183/IMX183C (Rev.15)
+//  20.2 MegaPixel
+
+static void vc_init_ctrl_imx183(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX183")
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        GAIN_LOG(1957, 27000, 2048, 2048)
+        
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
+
+        FRAME(0, 0, 5440, 3648)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,    1440,    5,  0x1ffff,  3728,  255,   50,   3599997)
+        MODE( 1, 2, FORMAT_RAW10, 0,    1440,    5,  0x1ffff,  3728,  255,   50,   3599997)
+        MODE( 2, 2, FORMAT_RAW12, 0,    1724,    5,  0x1ffff,  3728,  255,   50,   3599997)
+        MODE( 3, 4, FORMAT_RAW08, 0,     720,    5,  0x1ffff,  3728,  255,   50,   3599997)
+        MODE( 4, 4, FORMAT_RAW10, 0,     720,    5,  0x1ffff,  3728,  255,   50,   3599997)
+        MODE( 5, 4, FORMAT_RAW12, 0,     862,    5,  0x1ffff,  3728,  255,   50,   3599997)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX226/IMX226C (Rev.16)
+//  12.4 MegaPixel Starvis
+
+static void vc_init_ctrl_imx226(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX226")
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        GAIN_LOG(1957, 27000, 2048, 2048)
+        
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
+
+        FRAME(0, 0, 3904, 3000)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,    1072,    5,  0x1ffff,  3079,  255,   50,   2698560)
+        MODE( 1, 2, FORMAT_RAW10, 0,    1072,    5,  0x1ffff,  3079,  255,   50,   2698560)
+        MODE( 2, 2, FORMAT_RAW12, 0,    1288,    5,  0x1ffff,  3079,  255,   50,   2698560)
+        MODE( 3, 4, FORMAT_RAW08, 0,     536,    5,  0x1ffff,  3079,  255,   50,   2698560)
+        MODE( 4, 4, FORMAT_RAW10, 0,     536,    5,  0x1ffff,  3079,  255,   50,   2698560)
+        MODE( 5, 4, FORMAT_RAW12, 0,     644,    5,  0x1ffff,  3079,  255,   50,   2698560)
+
+        ctrl->clk_pixel                 = 72000000;
+
+        ctrl->flags                    |= FLAG_FORMAT_GBRG;
+        ctrl->flags                    |= FLAG_TRIGGER_STREAM_EDGE | FLAG_TRIGGER_STREAM_LEVEL;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX250/IMX250C (Rev.09)
+//  5.01 MegaPixel Pregius
+
+static void vc_init_ctrl_imx250(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX250")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 2432, 2048)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     540,   10,  0xfffff,  2094,  255,   15,   1580040)
+        MODE( 1, 2, FORMAT_RAW10, 0,     660,   10,  0xfffff,  2094, 1023,   60,   1580040)
+        MODE( 2, 2, FORMAT_RAW12, 0,     780,   10,  0xfffff,  2094, 4095,  240,   1580040)
+        MODE( 3, 4, FORMAT_RAW08, 0,     350,   10,  0xfffff,  2094,  255,   15,   1580040)
+        MODE( 4, 4, FORMAT_RAW10, 0,     430,   10,  0xfffff,  2094, 1023,   60,   1580040)
+        MODE( 5, 4, FORMAT_RAW12, 0,     510,   10,  0xfffff,  2094, 4095,  240,   1580040)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX252/IMX252C (Rev.12)
+//  3.15 MegaPixel Pregius
+
+static void vc_init_ctrl_imx252(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX252")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 2048, 1536)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     460,   10,  0xfffff,  1582,  255,   15,   1063754)
+        MODE( 1, 2, FORMAT_RAW10, 0,     560,   10,  0xfffff,  1582, 1023,   60,   1063754)
+        MODE( 2, 2, FORMAT_RAW12, 0,     672,   10,  0xfffff,  1582, 4095,  240,   1063754)
+        MODE( 3, 4, FORMAT_RAW08, 0,     310,   10,  0xfffff,  1582,  255,   15,   1063754)
+        MODE( 4, 4, FORMAT_RAW10, 0,     380,   10,  0xfffff,  1582, 1023,   60,   1063754)
+        MODE( 5, 4, FORMAT_RAW12, 0,     444,   10,  0xfffff,  1582, 4095,  240,   1063754)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX264/IMX264C (Rev.05)
+//  5.1 MegaPixel Pregius
+
+static void vc_init_ctrl_imx264(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX264")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 2432, 2048)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     996,   10,  0xfffff,  2100,  255,   15,   1580040)
+        MODE( 1, 2, FORMAT_RAW10, 0,     996,   10,  0xfffff,  2100, 1023,   60,   1580040)
+        MODE( 2, 2, FORMAT_RAW12, 0,     996,   10,  0xfffff,  2100, 4095,  240,   1580040)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX265/IMX265C (Rev.05)
+//  3.2 MegaPixel Pregius
+
+static void vc_init_ctrl_imx265(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX265")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 2048, 1536)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     846,   10,  0xfffff,  1587,  255,  255,   1580040)
+        MODE( 1, 2, FORMAT_RAW10, 0,     846,   10,  0xfffff,  1587, 1023, 1023,   1580040)
+        MODE( 2, 2, FORMAT_RAW12, 0,     846,   10,  0xfffff,  1587, 4095, 4095,   1580040)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX273/IMX273C (Rev.16)
+//  1.56 MegaPixel Pregius
+
+static void vc_init_ctrl_imx273(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX273")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 1440, 1080)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     336,   15,  0xfffff,  1130,  255,   15,    519230)
+        MODE( 1, 2, FORMAT_RAW10, 0,     420,   15,  0xfffff,  1130, 1023,   60,    519230)
+        MODE( 2, 2, FORMAT_RAW12, 0,     480,   15,  0xfffff,  1130, 4095,  240,    519230)
+        MODE( 3, 4, FORMAT_RAW08, 0,     238,   15,  0xfffff,  1130,  255,   15,    519230)
+        MODE( 4, 4, FORMAT_RAW10, 0,     290,   15,  0xfffff,  1130, 1032,   60,    519230)
+        MODE( 5, 4, FORMAT_RAW12, 0,     396,   15,  0xfffff,  1130, 4095,  240,    519230)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX290 (Rev.02)
+//  2.0 MegaPixel Starvis
+
+static void vc_init_ctrl_imx290(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX290")
+
+        vc_init_ctrl_imx290_base(ctrl, desc);
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,     550,    1,  0x3ffff, 0x465,  511,   60,         0)
+        MODE( 1, 2, FORMAT_RAW12, 0,     550,    1,  0x3ffff, 0x465,  511,  240,         0)
+        MODE( 2, 4, FORMAT_RAW10, 0,     550,    1,  0x3ffff, 0x465,  511,   60,         0)
+        MODE( 3, 4, FORMAT_RAW12, 0,     550,    1,  0x3ffff, 0x465,  511,  240,         0)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX296/IMX296C (Rev.43)
+//  1.56 MegaPixel Pregius
+
+static void vc_init_ctrl_imx296(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX296")
+
+        vc_init_ctrl_imx296_base(ctrl, desc);
+
+        FRAME(0, 0, 1440, 1080)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 1, FORMAT_RAW10, 0,    1100,    5,  0xfffff,  1110, 1023,   60,    883008)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX297 (Rev.43)
+//  0.39 MegaPixel Pregius
+
+static void vc_init_ctrl_imx297(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{       
+        INIT_MESSAGE("IMX297")
+
+        vc_init_ctrl_imx296_base(ctrl, desc);
+
+        FRAME(0, 0, 704, 540) // 720 isn't divisible by 32
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 1, FORMAT_RAW10, 0,     550,    5,  0xfffff,  1110,  511,   60,    883008)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX327C (Rev.02)
+//  2 MegaPixel Starvis
+
+// NOTES:
+// - For vertical flipping VREVERSE 0x3007 = 0x01 has to be set.
+// - For horizontal flipping HREVERSE 0x3007 = 0x02 has to be set.
+// - For cropping WINMODE 0x3007 = 0x40 has to be set. Unfortunatly cropping mode does not reduce 
+//   the image size. The image is always filled up to a size of 1920x1080.
+// - To increase the frame rate it is possible to reduce VMAX. In this case the image height is forced
+//   to be height = VMAX - 15. This is independend of the cropped image height.
+// => Cropping is not properly supported.
+// => Frame rate increase by image height reduction could be implemented. 
+//    But, it need an own implementation.
+
+static void vc_init_ctrl_imx327(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX327")
+
+        vc_init_ctrl_imx290_base(ctrl, desc);
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,    1100,    1,  0x3ffff, 0x465,  511,   60,         0)
+        MODE( 1, 2, FORMAT_RAW12, 0,    1100,    1,  0x3ffff, 0x465,  511,  240,         0)
+        MODE( 2, 4, FORMAT_RAW10, 0,    1100,    1,  0x3ffff, 0x465,  511,   60,         0)
+        MODE( 3, 4, FORMAT_RAW12, 0,    1100,    1,  0x3ffff, 0x465,  511,  240,         0)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX335 (Rev.02)
+//  5.0 MegaPixel Starvis
+
+static void vc_init_ctrl_imx335(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX335")
+
+        GAIN_LIN(240, 72000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3302, .m = 0x3303 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3030, .m = 0x3031, .h = 0x3032, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(7, 52, 2592, 1944)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,   0x113,    9,  0xfffff,  4500, 1023,   50,         0)
+        MODE( 1, 2, FORMAT_RAW12, 0,   0x226,    9,  0xfffff,  4500, 1023,   50,         0)
+        MODE( 2, 4, FORMAT_RAW10, 0,   0x113,    9,  0xfffff,  4500, 1023,   50,         0)
+        MODE( 3, 4, FORMAT_RAW12, 0,   0x226,    9,  0xfffff,  4500, 1023,   50,         0)
+
+        ctrl->flags                    |= FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_DOUBLE_HEIGHT;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX392/IMX392C (Rev.08)
+//  2.3 MegaPixel Pregius
+
+static void vc_init_ctrl_imx392(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX392")
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        FRAME(0, 0, 1920, 1200)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     448,   10,  0xfffff,  1252,  255,   15,   1063754)
+        MODE( 1, 2, FORMAT_RAW10, 0,     530,   10,  0xfffff,  1252, 1023,   60,   1063754)
+        MODE( 2, 2, FORMAT_RAW12, 0,     624,   10,  0xfffff,  1252, 4095,  240,   1063754)
+        MODE( 3, 4, FORMAT_RAW08, 0,     294,   10,  0xfffff,  1252,  255,   15,   1063754)
+        MODE( 4, 4, FORMAT_RAW10, 0,     355,   10,  0xfffff,  1252, 1023,   60,   1063754)
+        MODE( 5, 4, FORMAT_RAW12, 0,     441,   10,  0xfffff,  1252, 4095,  240,   1063754)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX412C (Rev.05)
+//  12.3 MegaPixel Starvis
+//  
+//  TODO: 
+//  - No black level (0x0B04 <= 1 - Black level correction enable)
+
+#define IMX412_BINNING_MODE            0x0900
+#define IMX412_BINNING_MODE_DISABLE    0x00
+#define IMX412_BINNING_MODE_ENABLE     0x01
+#define IMX412_BINNING_TYPE            0x0901
+#define IMX412_BINNING_WEIGHTING       0x0902
+#define IMX412_BINNING_WEIGHTING_AVG   0x00
+#define IMX412_BINNING_WEIGHTING_SUM   0x01
+#define IMX412_BINNING_TYPE_EXT_EN     0x3f42
+#define IMX412_BINNING_TYPE_H_EXT      0x3f43
+#define IMX412_BLACKLEVEL_ENABLE       0x3030
+
+static void vc_init_ctrl_imx412(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX412")
+        
+        GAIN_REC(978, 13400, 1024, 1024)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3033, .m = 0x3032 };
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0341, .m = 0x0340, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.shs               = (vc_csr4) { .l = 0x0203, .m = 0x0202, .h = 0x0000, .u = 0x0000 };
+
+        FRAME(0, 0, 4032, 3040)
+        // All read out      binning    hmax  vmax      vmax    vmax  blkl  blkl  retrigger
+        //                      mode           min       max     def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,     436,   10,   0xffff, 0x0c14, 1023,   40,         0)
+        MODE( 1, 4, FORMAT_RAW10, 0,     218,   10,   0xffff, 0x0c14, 1023,   40,         0)
+
+        MODE( 2, 2, FORMAT_RAW10, 1,     436,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 3, 4, FORMAT_RAW10, 1,     218,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 4, 2, FORMAT_RAW10, 2,     436,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 5, 4, FORMAT_RAW10, 2,     218,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 6, 2, FORMAT_RAW10, 3,     436,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 7, 4, FORMAT_RAW10, 3,     218,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 8, 2, FORMAT_RAW10, 4,     436,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE( 9, 4, FORMAT_RAW10, 4,     218,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE(10, 2, FORMAT_RAW10, 5,     436,   10,   0xffff, 0x0624, 1023,   40,         0)
+        MODE(11, 4, FORMAT_RAW10, 5,     218,   10,   0xffff, 0x0624, 1023,   40,         0)
+
+        ctrl->clk_ext_trigger           = 27000000;
+        ctrl->clk_pixel                 = 27000000;
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_DISABLE },
+                { IMX412_BINNING_TYPE, 0x11 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[0])
+        BINNING_START(ctrl->binnings[1], 1, 2)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_ENABLE },
+                { IMX412_BINNING_WEIGHTING, IMX412_BINNING_WEIGHTING_SUM },
+                { IMX412_BINNING_TYPE, 0x12 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[1])
+        BINNING_START(ctrl->binnings[2], 2, 2)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_ENABLE },
+                { IMX412_BINNING_WEIGHTING, IMX412_BINNING_WEIGHTING_SUM },
+                { IMX412_BINNING_TYPE, 0x22 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[2])
+        BINNING_START(ctrl->binnings[3], 4, 2)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_ENABLE },
+                { IMX412_BINNING_WEIGHTING, IMX412_BINNING_WEIGHTING_SUM },
+                { IMX412_BINNING_TYPE, 0x42 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[3])
+        BINNING_START(ctrl->binnings[4], 8, 2)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_ENABLE },
+                { IMX412_BINNING_WEIGHTING, IMX412_BINNING_WEIGHTING_SUM },
+                { IMX412_BINNING_TYPE, 0x82 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[4])
+        BINNING_START(ctrl->binnings[5], 16, 2)
+                { IMX412_BINNING_MODE, IMX412_BINNING_MODE_ENABLE },
+                { IMX412_BINNING_WEIGHTING, IMX412_BINNING_WEIGHTING_SUM },
+                { IMX412_BINNING_TYPE, 0x02 },
+                { IMX412_BINNING_TYPE_EXT_EN, 0x01 },
+                { IMX412_BINNING_TYPE_H_EXT, 0x01 },
+                { IMX412_BLACKLEVEL_ENABLE, 0x01 }
+        BINNING_END(ctrl->binnings[5])
+
+        ctrl->max_binning_modes_used = 5;
+
+        ctrl->flags                     = FLAG_RESET_ALWAYS;
+        ctrl->flags                    |= FLAG_EXPOSURE_NORMAL;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_SLAVE;
+        ctrl->flags                    |= FLAG_USE_BINNING_INDEX;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX415C (Rev.02)
+//  8.3 MegaPixel Starvis
+
+static void vc_init_ctrl_imx415(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX415")
+        
+        GAIN_LIN(240, 72000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x30e2, .m = 0x30e3 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3024, .m = 0x3025, .h = 0x3026, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 3840, 2160)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,    1042,    8,  0xfffff, 0x8ca, 1023,   50,         0)
+        MODE( 1, 4, FORMAT_RAW10, 0,     551,    8,  0xfffff, 0x8ca, 1023,   50,         0)
+
+        ctrl->clk_pixel                 = 74250000;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_DOUBLE_HEIGHT;
+        ctrl->flags                    |= FLAG_FORMAT_GBRG;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+}
+
+// -------------------------------------------------------------
+//  Settings for IMX462 (Rev.01)
+//  2.0 MegaPixel Starvis
+
+static void vc_init_ctrl_imx462(struct vc_ctrl *ctrl, struct vc_desc *desc)
+{
+        INIT_MESSAGE("IMX462")
+
+        vc_init_ctrl_imx290_base(ctrl, desc);
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW10, 0,    1100,    1,  0x3ffff, 0x465,  511,   60,         0)
+        MODE( 1, 4, FORMAT_RAW10, 0,     550,    1,  0x3ffff, 0x465,  511,   60,         0)
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX565 (Rev.03)
+//  12.4 MegaPixel Pregius S
+
+#define IMX56X_HV_MODE                  0x303c
+#define IMX56X_BINNING_MODE_DISABLE     0x00
+#define IMX56X_BINNING_MODE_ENABLE      0x10
+#define IMX56X_VBLK_HWIDTH_UPPER        0x30d1
+#define IMX56X_VBLK_HWIDTH_LOWER        0x30d0
+#define IMX56X_FINFO_HWIDTH_UPPER       0x30d3
+#define IMX56X_FINFO_HWIDTH_LOWER       0x30d2
+#define IMX56X_EAV_SELECT               0x3942
+#define IMX56X_EAV_SELECT_VALUE         0x03
+
+#define IMX56X_GMRWT                    0x30e2
+#define IMX56X_GMTWT                    0x30e3
+#define IMX56X_GAINDLY                  0x30e5
+#define IMX56X_GSDLY                    0x30e6
+
+static void vc_init_ctrl_imx565(struct vc_ctrl *ctrl, struct vc_desc *desc)
+{
+        INIT_MESSAGE("IMX565")
+
+        GAIN_LIN(480, 48000)
+        
+        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x3514, .m = 0x3515 };
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x30d8, .m = 0x30d9, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 4128, 3000)
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,    1070,   18, 0xffffff, 0xc2c,  255,   15,   2410776)
+        MODE( 1, 2, FORMAT_RAW10, 0,    1328,   16, 0xffffff, 0xc2a, 1023,   60,   2990142)
+        MODE( 2, 2, FORMAT_RAW12, 0,    1586,   14, 0xffffff, 0xc26, 4095,  240,   3568752)
+        MODE( 3, 4, FORMAT_RAW08, 0,     555,   30, 0xffffff, 0xc40,  255,   15,   1256094)
+        MODE( 4, 4, FORMAT_RAW10, 0,     684,   26, 0xffffff, 0xc3a, 1023,   60,   1546074)
+        MODE( 5, 4, FORMAT_RAW12, 0,     812,   22, 0xffffff, 0xc34, 4095,  240,   1833030)
+
+        // Binning
+        MODE( 6, 2, FORMAT_RAW08, 1,     554,  32, 0xffffff, 0x644,  255,   15,    638982)
+        MODE( 7, 2, FORMAT_RAW10, 1,     683,  28, 0xffffff, 0x640, 1023,   60,    785808)
+        MODE( 8, 2, FORMAT_RAW12, 1,     812,  24, 0xffffff, 0x638, 4095,  240,    931878)
+        MODE( 9, 4, FORMAT_RAW08, 1,     297,  52, 0xffffff, 0x668,  255,   15,    347760)
+        MODE(10, 4, FORMAT_RAW10, 1,     361,  44, 0xffffff, 0x65c, 1023,   60,    420552)
+        MODE(11, 4, FORMAT_RAW12, 1,     425,  40, 0xffffff, 0x654, 4095,  240,    493884)
+        
+        // Special registers for binning mode
+        BINNING_MODE_REGS(  6, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x1c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x0c } );
+        BINNING_MODE_REGS(  7, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x18 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x0c } );
+        BINNING_MODE_REGS(  8, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x14 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x08 } );
+        BINNING_MODE_REGS(  9, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x30 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x18 } );
+        BINNING_MODE_REGS( 10, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x28 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x14 } );
+        BINNING_MODE_REGS( 11, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x24 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_DISABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[0])
+
+        BINNING_START(ctrl->binnings[1], 2, 2)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_ENABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[1])
+
+        ctrl->max_binning_modes_used = 1;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_PREGIUS_S;
+        ctrl->flags                    |= FLAG_USE_BINNING_INDEX;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH | 
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX566 (Rev.03)
+//  8.3 MegaPixel Pregius S
+
+static void vc_init_ctrl_imx566(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX566")
+
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x30d8, .m = 0x30d9, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 2848, 2848)
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     752,   24, 0xffffff, 0xb98,  255,   15,   1612278)
+        MODE( 1, 2, FORMAT_RAW10, 0,     930,   20, 0xffffff, 0xb92, 1023,   60,   1991196)
+        MODE( 2, 2, FORMAT_RAW12, 0,    1109,   18, 0xffffff, 0xb8c, 4095,  240,   2371194)
+        MODE( 3, 4, FORMAT_RAW08, 0,     396,   40, 0xffffff, 0xbb0,  255,   15,    854172)
+        MODE( 4, 4, FORMAT_RAW10, 0,     485,   34, 0xffffff, 0xba6, 1023,   60,   1043334)
+        MODE( 5, 4, FORMAT_RAW12, 0,     574,   30, 0xffffff, 0xba0, 4095,  240,   1233144)
+
+        // Binning
+        MODE( 6, 2, FORMAT_RAW08, 1,     396,   40, 0xffffff, 0x604,  255,   15,    430812)
+        MODE( 7, 2, FORMAT_RAW10, 1,     485,   36, 0xffffff, 0x5fc, 1023,   60,    524826)
+        MODE( 8, 2, FORMAT_RAW12, 1,     575,   32, 0xffffff, 0x5f4, 4095,  240,    620568)
+        MODE( 9, 4, FORMAT_RAW08, 1,     218,   72, 0xffffff, 0x634,  255,   15,    242892)
+        MODE(10, 4, FORMAT_RAW10, 1,     262,   60, 0xffffff, 0x620, 1023,   60,    288846)
+        MODE(11, 4, FORMAT_RAW12, 1,     307,   52, 0xffffff, 0x614, 4095,  240,    336690)
+
+        // Special registers for binning mode
+        BINNING_MODE_REGS(  6, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x24 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  7, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x20 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  8, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x1c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x0c } );
+        BINNING_MODE_REGS(  9, { IMX56X_GMRWT, 0x0c }, { IMX56X_GMTWT, 0x44 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x1c } );
+        BINNING_MODE_REGS( 10, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x38 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x18 } );
+        BINNING_MODE_REGS( 11, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x30 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x14 } );
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_DISABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[0])
+
+        BINNING_START(ctrl->binnings[1], 2, 2)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_ENABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[1])
+
+        ctrl->max_binning_modes_used = 1;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_PREGIUS_S;
+        ctrl->flags                    |= FLAG_USE_BINNING_INDEX;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX567 (Rev.03)
+//  5.1 MegaPixel Pregius S
+
+static void vc_init_ctrl_imx567(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX567")
+
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x30d8, .m = 0x30d9, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 2464, 2064)
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     656,   26, 0xffffff, 0x88a,  255,   15,   1058562)
+        MODE( 1, 2, FORMAT_RAW10, 0,     810,   22, 0xffffff, 0x884, 1023,   60,   1273590)
+        MODE( 2, 2, FORMAT_RAW12, 0,     965,   20, 0xffffff, 0x880, 4095,  240,   1514484)
+        MODE( 3, 4, FORMAT_RAW08, 0,     348,   46, 0xffffff, 0x8a8,  255,   15,    553716)
+        MODE( 4, 4, FORMAT_RAW10, 0,     425,   38, 0xffffff, 0x89e, 1023,   60,    673812)
+        MODE( 5, 4, FORMAT_RAW12, 0,     502,   34, 0xffffff, 0x896, 4095,  240,    793692)
+
+        // Binning
+        MODE( 6, 2, FORMAT_RAW08, 1,     348,   48, 0xffffff, 0x488,  255,   15,    285444)
+        MODE( 7, 2, FORMAT_RAW10, 1,     425,   40, 0xffffff, 0x47c, 1023,   60,    346140)
+        MODE( 8, 2, FORMAT_RAW12, 1,     503,   36, 0xffffff, 0x474, 4095,  240,    406782)
+        MODE( 9, 4, FORMAT_RAW08, 1,     194,   80, 0xffffff, 0x4b8,  255,   15,    164214)
+        MODE(10, 4, FORMAT_RAW10, 1,     232,   68, 0xffffff, 0x4a8, 1023,   60,    194346)
+        MODE(11, 4, FORMAT_RAW12, 1,     271,   60, 0xffffff, 0x498, 4095,  240,    224640)
+
+        // Special registers for binning mode
+        BINNING_MODE_REGS(  6, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x2c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x14 } );
+        BINNING_MODE_REGS(  7, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x24 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  8, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x20 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  9, { IMX56X_GMRWT, 0x0c }, { IMX56X_GMTWT, 0x4c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x20 } );
+        BINNING_MODE_REGS( 10, { IMX56X_GMRWT, 0x0c }, { IMX56X_GMTWT, 0x40 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x1c } );
+        BINNING_MODE_REGS( 11, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x38 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x18 } );
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_DISABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[0])
+
+        BINNING_START(ctrl->binnings[1], 2, 2)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_ENABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[1])
+
+        ctrl->max_binning_modes_used = 1;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_PREGIUS_S;
+        ctrl->flags                    |= FLAG_USE_BINNING_INDEX;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX568 (Rev.04)
+//  5.1 MegaPixel Pregius S
+
+static void vc_init_ctrl_imx568(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX568")
+
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x30d8, .m = 0x30d9, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 2464, 2064)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     656,   26, 0xffffff, 0x88a,  255,   15,   1058562)
+        MODE( 1, 2, FORMAT_RAW10, 0,     810,   22, 0xffffff, 0x884, 1023,   60,   1273590)
+        MODE( 2, 2, FORMAT_RAW12, 0,     965,   20, 0xffffff, 0x880, 4095,  240,   1514484)
+        MODE( 3, 4, FORMAT_RAW08, 0,     348,   46, 0xffffff, 0x8a8,  255,   15,    553716)
+        MODE( 4, 4, FORMAT_RAW10, 0,     425,   38, 0xffffff, 0x89e, 1023,   60,    673812)
+        MODE( 5, 4, FORMAT_RAW12, 0,     502,   34, 0xffffff, 0x896, 4095,  240,    793692)
+
+        // Binning
+        MODE( 6, 2, FORMAT_RAW08, 1,     348,   48, 0xffffff, 0x488,  255,   15,    285444)
+        MODE( 7, 2, FORMAT_RAW10, 1,     425,   40, 0xffffff, 0x47c, 1023,   60,    346140)
+        MODE( 8, 2, FORMAT_RAW12, 1,     503,   36, 0xffffff, 0x474, 4095,  240,    406782)
+        MODE( 9, 4, FORMAT_RAW08, 1,     194,   80, 0xffffff, 0x4b8,  255,   15,    164214)
+        MODE(10, 4, FORMAT_RAW10, 1,     232,   68, 0xffffff, 0x4a8, 1023,   60,    194346)
+        MODE(11, 4, FORMAT_RAW12, 1,     271,   60, 0xffffff, 0x498, 4095,  240,    224640)
+
+        // Special registers for binning mode
+        BINNING_MODE_REGS(  6, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x2c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x14 } );
+        BINNING_MODE_REGS(  7, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x24 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  8, { IMX56X_GMRWT, 0x04 }, { IMX56X_GMTWT, 0x20 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x10 } );
+        BINNING_MODE_REGS(  9, { IMX56X_GMRWT, 0x0c }, { IMX56X_GMTWT, 0x4c }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x20 } );
+        BINNING_MODE_REGS( 10, { IMX56X_GMRWT, 0x0c }, { IMX56X_GMTWT, 0x40 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x1c } );
+        BINNING_MODE_REGS( 11, { IMX56X_GMRWT, 0x08 }, { IMX56X_GMTWT, 0x38 }, { IMX56X_GAINDLY, 0x04 }, { IMX56X_GSDLY, 0x18 } );
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_DISABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[0])
+
+        BINNING_START(ctrl->binnings[1], 2, 2)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_ENABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[1])
+
+        ctrl->max_binning_modes_used = 1;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_PREGIUS_S;
+        ctrl->flags                    |= FLAG_USE_BINNING_INDEX;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX900 (Rev.00)
+//  3.2 MegaPixel Pregius S
+
+static void vc_init_ctrl_imx900(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("IMX900")
+
+        GAIN_LIN(480, 48000)
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        FRAME(0, 0, 2048, 1536)
+
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     460,   68, 0xffffff, 1716,  255,   15,   1058562)
+        MODE( 1, 2, FORMAT_RAW10, 0,     564,   56, 0xffffff, 1697, 1023,   60,   1273590)
+        MODE( 2, 2, FORMAT_RAW12, 0,     667,   46, 0xffffff, 1681, 4095,  240,   1514484)
+        MODE( 3, 4, FORMAT_RAW08, 0,     338,   92, 0xffffff, 1755,  255,   15,    553716)
+        MODE( 4, 4, FORMAT_RAW10, 0,     364,   85, 0xffffff, 1743, 1023,   60,    673812)
+        MODE( 5, 4, FORMAT_RAW12, 0,     610,   51, 0xffffff, 1689, 4095,  240,    793692)
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+
+        ctrl->flags                    |= FLAG_PREGIUS_S;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+
+        BINNING_START(ctrl->binnings[0], 0, 0)
+                { IMX56X_HV_MODE, IMX56X_BINNING_MODE_DISABLE },
+                { IMX56X_EAV_SELECT, IMX56X_EAV_SELECT_VALUE }
+        BINNING_END(ctrl->binnings[0])
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for OV7251 (Rev.01)
+//  0.3 MegaPixel OmniPixel3-GS
+//
+//  TODO: 
+//  - No flash out
+
+static void vc_init_ctrl_ov7251(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("OV7251")
+
+        ctrl->exposure                  = (vc_control) { .min =   1, .max =   1000000, .def =  10000 };
+        GAIN_FRA(255, 12000)
+
+        ctrl->csr.sen.h_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.v_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.flash_duration    = (vc_csr4) { .l = 0x3b8f, .m = 0x3b8e, .h = 0x3b8d, .u = 0x3b8c };
+        ctrl->csr.sen.flash_offset      = (vc_csr4) { .l = 0x3b8b, .m = 0x3b8a, .h = 0x3b89, .u = 0x3b88 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
+        // NOTE: Modules rom table contains swapped address assigment.
+        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x350b, .m = 0x350a };
+        
+        FRAME(0, 0, 640, 480)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 1, FORMAT_RAW08, 0,     772,    0,   0xffff,   598,    0,    0,         0)
+        MODE( 1, 1, FORMAT_RAW10, 0,     772,    0,   0xffff,   598,    0,    0,         0)
+
+        ctrl->flash_factor              = 1758241 >> 4; // (1000 << 4)/9100 >> 4
+        ctrl->flash_toffset             = 4;
+
+        ctrl->flags                     = FLAG_EXPOSURE_OMNIVISION;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for OV9281 (Rev.03)
+//  1.02 MegaPixel OmniPixel3-GS
+
+static void vc_init_ctrl_ov9281(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        INIT_MESSAGE("OV9281")
+        
+        ctrl->exposure                  = (vc_control) { .min = 146, .max =    595000, .def =  10000 };
+        GAIN_FRA(255, 12000)
+
+        ctrl->csr.sen.h_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.v_end             = (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.flash_duration	= (vc_csr4) { .l = 0x3928, .m = 0x3927, .h = 0x3926, .u = 0x3925 };
+        ctrl->csr.sen.flash_offset      = (vc_csr4) { .l = 0x3924, .m = 0x3923, .h = 0x3922, .u = 0x0000 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
+        // NOTE: Modules rom table contains swapped address assigment.
+        ctrl->csr.sen.gain              = (vc_csr2) { .l = 0x3509, .m = 0x0000 };
+        
+        FRAME(0, 0, 1280, 800)
+        // All read out      binning    hmax  vmax      vmax   vmax  blkl  blkl  retrigger
+        //                      mode           min       max    def   max   def
+        MODE( 0, 2, FORMAT_RAW08, 0,     227,   16,   0xffff,   910,    0,    0,         0)
+        MODE( 1, 2, FORMAT_RAW10, 0,     227,   16,   0xffff,   910,    0,    0,         0)
+
+        ctrl->clk_ext_trigger           = 25000000;
+        ctrl->clk_pixel                 = 25000000;
+
+        ctrl->flash_factor              = 1758241 >> 4; // (1000 << 4)/9100 >> 4
+        ctrl->flash_toffset             = 4;
+
+        ctrl->flags                     = FLAG_EXPOSURE_OMNIVISION;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL;
+}
+
+
+int vc_mod_ctrl_init(struct vc_ctrl* ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_init_ctrl(ctrl, desc);
+
+        switch(desc->mod_id) {
+        case MOD_ID_IMX178: vc_init_ctrl_imx178(ctrl, desc); break;
+        case MOD_ID_IMX183: vc_init_ctrl_imx183(ctrl, desc); break;
+        case MOD_ID_IMX226: vc_init_ctrl_imx226(ctrl, desc); break;
+        case MOD_ID_IMX250: vc_init_ctrl_imx250(ctrl, desc); break;
+        case MOD_ID_IMX252: vc_init_ctrl_imx252(ctrl, desc); break;
+        case MOD_ID_IMX264: vc_init_ctrl_imx264(ctrl, desc); break;
+        case MOD_ID_IMX265: vc_init_ctrl_imx265(ctrl, desc); break;
+        case MOD_ID_IMX273: vc_init_ctrl_imx273(ctrl, desc); break;
+        case MOD_ID_IMX290: vc_init_ctrl_imx290(ctrl, desc); break;
+        case MOD_ID_IMX296: vc_init_ctrl_imx296(ctrl, desc); break;
+        case MOD_ID_IMX297: vc_init_ctrl_imx297(ctrl, desc); break;
+        case MOD_ID_IMX327: vc_init_ctrl_imx327(ctrl, desc); break;
+        case MOD_ID_IMX335: vc_init_ctrl_imx335(ctrl, desc); break;
+        case MOD_ID_IMX392: vc_init_ctrl_imx392(ctrl, desc); break;
+        case MOD_ID_IMX412: vc_init_ctrl_imx412(ctrl, desc); break;
+        case MOD_ID_IMX415: vc_init_ctrl_imx415(ctrl, desc); break;
+        case MOD_ID_IMX462: vc_init_ctrl_imx462(ctrl, desc); break;
+        case MOD_ID_IMX565: vc_init_ctrl_imx565(ctrl, desc); break;
+        case MOD_ID_IMX566: vc_init_ctrl_imx566(ctrl, desc); break;
+        case MOD_ID_IMX567: vc_init_ctrl_imx567(ctrl, desc); break;
+        case MOD_ID_IMX568: vc_init_ctrl_imx568(ctrl, desc); break;
+        case MOD_ID_IMX900: vc_init_ctrl_imx900(ctrl, desc); break;
+        case MOD_ID_OV7251: vc_init_ctrl_ov7251(ctrl, desc); break;
+        case MOD_ID_OV9281: vc_init_ctrl_ov9281(ctrl, desc); break;
+        default:
+                vc_err(dev, "%s(): Detected module not supported!\n", __FUNCTION__);
+                return 1;
+        }
+
+        return 0;
+}
\ No newline at end of file
diff --git a/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.h b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.h
new file mode 100644
index 0000000..38f78b9
--- /dev/null
+++ b/vvcam/v4l2/sensor/vc-mipi-vvcam/vc_mipi_modules.h
@@ -0,0 +1,34 @@
+#ifndef _VC_MIPI_MODULES_H
+#define _VC_MIPI_MODULES_H
+
+#include "vc_mipi_core.h"
+
+#define MOD_ID_IMX178           0x0178
+#define MOD_ID_IMX183           0x0183
+#define MOD_ID_IMX226           0x0226
+#define MOD_ID_IMX264           0x0264
+#define MOD_ID_IMX265           0x0265
+#define MOD_ID_IMX250           0x0250
+#define MOD_ID_IMX252           0x0252
+#define MOD_ID_IMX273           0x0273
+#define MOD_ID_IMX290           0x0290
+#define MOD_ID_IMX296           0x0296
+#define MOD_ID_IMX297           0x0297
+#define MOD_ID_IMX327           0x0327
+#define MOD_ID_IMX335           0x0335
+#define MOD_ID_IMX392           0x0392
+#define MOD_ID_IMX412           0x0412
+#define MOD_ID_IMX415           0x0415
+#define MOD_ID_IMX462           0x0462
+#define MOD_ID_IMX565           0x0565
+#define MOD_ID_IMX566           0x0566
+#define MOD_ID_IMX567           0x0567
+#define MOD_ID_IMX568           0x0568
+#define MOD_ID_IMX900           0x0900
+#define MOD_ID_OV7251           0x7251
+#define MOD_ID_OV9281           0x9281
+
+int vc_mod_is_color_sensor(struct vc_desc *desc);
+int vc_mod_ctrl_init(struct vc_ctrl* ctrl, struct vc_desc* desc);
+
+#endif // _VC_MIPI_MODULES_H
-- 
2.25.1

